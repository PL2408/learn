Опанувавши цей розділ, ви зможете:

Зрозуміти основні концепції та особливості розробки, для яких був розроблений і використовується Git.
Обговорювати, чим Git відрізняється від попередніх систем контролю вихідного коду, зокрема, тим, що він від самого початку був розроблений для полегшення масової розподіленої розробки з багатьма, навіть тисячами, учасників. 
Зрозуміти, як сховище Git'а містить повну історію проєкту і може бути повернуте до будь-якого попереднього стану. 
Пояснити, як Git позбавляє потреби в одному централізованому репозиторії; всі учасники мають повну копію локально, і який репозиторій є авторитетним - це суспільно-політичне, а не технічне рішення. 
Пояснити роль об'єктів та змісту (index).
Пояснити, як Git базується на вмісті, а не на шляху та іменах файлів. 
Пояснити різницю між коммітом та публікацією.
Описати різницю між апстрим та даунстрим репозиторіями та пояснити процес форкінга. 

------------------------------------Концепції-------------------------------------------------

Багато основних команд Git'а схожі на команди інших систем керування версіями. Такі операції, як додавання файлів, фіксація змін, порівняння з попередніми версіями та ведення журналу історії, є загальними для будь-якої серйозної системи керування версіями.

Однак під капотом Git значно відрізняється від багатьох своїх попередників. Наприклад, у Git'і файл не є основним об'єктом. Звичайні операції, які можуть бути дещо громіздкими в інших системах, наприклад, перейменування файлу, у Git'і надзвичайно прості.

Довгі шістнадцяткові числа, пов'язані з коммітами, також є дещо дивними. Вони більше, ніж ідентифікатори. Вони містять контрольні суми, які обчислюються на основі вмісту репозиторіїв і внесених змін.

------------------------------------Особливості дизайну---------------------------------------

Git виріс зі спільноти розробників ядра Linux і був розроблений для задоволення її специфічних потреб. З часом він був прийнятий іншими проєктами, але його базова структура і мотивація показує його коріння. Тут ми перерахуємо бажані функції, багато з яких не можна було знайти в попередніх системах керування змінами, саме вони надихнули на розробку Git'а.

Сприяння розподіленій розробці
Розробники повинні були мати можливість працювати паралельно без постійної повторної синхронізації і без необхідності постійно звертатися до центрального репозиторію. 
Масштабування для роботи з великою кількістю розробників
Спільнота розробників ядра Linux налічує буквально тисячі розробників. З цим потрібно було впоратися ефективно і надійно. 
Досягнення високої швидкості та максимальної ефективності
Важливо уникати копіювання непотрібної інформації, використовувати стиснення, не перевантажувати мережі та вміти працювати з різними мережевими затримками.
Підтримувати високу цілісність і довіру
Безпека вимагає, щоб не можна було вносити несанкціоновані зміни, і щоб репозиторії були справжніми, а не підробними. Для цього використовуються криптографічні хеш-функції. 
Тримати всіх підзвітними
Всі зміни мають бути задокументовані та приписані тому, хто їх вніс. Завжди залишається слід, який можна відобразити. 
Зберігати незмінні дані в сховищі 
Інформація, така як історія проєкту, не може бути змінена.
Здійснюйте атомарні транзакції
Коли вносяться зміни, вони повинні пройти всі, або жодна з них не пройде. Це дозволяє уникнути залишення репозиторія у невизначеному або пошкодженому стані. 
Підтримка розгалуження та злиття
Git підтримує паралельні гілки розробки і має дуже надійні методи для об'єднання гілок, коли це необхідно.
Зробити кожен репозиторій незалежним
У кожному репозиторії зберігається вся історія. Вам ніколи не доведеться звертатися до центрального репозиторія. 
Працювати під вільною ліцензією
Git поширюється на умовах GPL, версія 2.

---------------------------------------Репозиторії--------------------------------------------

Репозиторій - це база даних. Він містить кожен біт інформації, необхідний для зберігання проєкту, керування версіями та відображення його історії.

Репозиторій Git'а містить не лише повну робочу копію всіх файлів, що складають вміст проєкту, але й копію самого репозиторія.

Кожен репозииторій також містить набір конфігураційних параметрів, таких як ім'я автора та адреса електронної пошти. Наприклад, якщо ми подивимося на файл .git/config з простого прикладу у попередньому розділі, то побачимо:

​$ cat .git/config

[core]

       repositoryformatversion = 0
       filemode = true
       bare = false
       logallrefupdates = true

[user]

       name = Another Genius
       email = a_genius@linux.com

Якщо ви клонуєте репозиторій Git'а (робите ще одну копію для когось іншого або навіть для себе), ця інформація про конфігурацію не переноситься. Натомість така інформація зберігається для кожного сайту, користувача та репозиторія окремо. 

Є дві важливі структури даних, які підтримуються у репозиторії: 

У сховищі об'єктів (object store) містить нутрощі проєкту, набір дискретних двійкових об'єктів. 
Зміст (index) – бінарний файл, який динамічно змінюється з розвитком проєкту. Він містить картину загальної структури проєкту в будь-який момент. 
Ми обговоримо ці структури детальніше. 

-----------------------------------Об’єкти та зміст (Index)-----------------------------------

Git зберігає чотири типи об'єктів у своєму сховищі об'єктів. Всі разом вони містять все, що відомо про проєкт і як побудований його поточний стан та його попередня історія. 

Блоби (двійковий великий об'єкт).
Це непрозора конструкція, яка містить версію вмісту файлу. Він не містить імені файлу або будь-яких інших метаданих, лише його вміст. 
Дерева
Записують ідентифікатори блобів, шляхи файлів, метадані файлів тощо для файлів у каталозі. Вони також можуть посилатися на підкаталоги та об'єкти всередині них. 
Комміти
Щоразу, коли до репозиторію вносяться зміни, створюється об'єкт комміту, що містить метадані, які повністю описують ці зміни. Кожен комміт вказує на об'єкт-дерево, який дає повний знімок проєкту. У коммітів є батьківські і дочірні об'єкти, за винятком початкового (або кореневого) комміту, який не має батьків. 
Теги
Призначають зручні для людини імена тим жахливо довгим шістнадцятковим числам, які використовуються всередині Git'у. 
Зміст (індекс) містить повну картину стану проєкту на зараз. Він тимчасовий і динамічний. Він змінюється з додаванням об'єктів або внесенням змін.

Такі зміни, як додавання, видалення, перейменування або переміщення файлів відображаються у модифікаціях змісту (індексу). Ці зміни зберігаються доти, доки ви не закоммітите їх у репозиторії.

Зміст (індекс) відіграє важливу роль у об'єднанні гілок репозиторія.

---------------------------------Контент vs. Шляхи файлів-------------------------------------

На відміну від більшості інших систем керування версіями, Git відстежує вміст, а не файли. Він не зберігає інформацію, засновану на іменах файлів або каталогів, структурі каталогів і розташуванні файлів. Це пов'язана інформація, яка не зберігається безпосередньо у блобах. 

Наприклад, припустимо, у вас є два файли у двох каталогах з різними іменами. Git зберігає лише один бінарний блок, пов'язаний з вмістом. Вміст асоціюється з унікальним шістнадцятковим рядком.

Якщо один з файлів змінено, його ідентифікатор змінюється, і тепер Git пов'язує новий блоб з новим вмістом. Порівняння відбувається дуже швидко, оскільки Git порівнює лише 160-розрядні ідентифікатори, а не порівнює власне блоби, а тим паче файли.

Коли файли змінюються, для кожної версії створюються нові, унікально ідентифіковані двійкові блоби. Інші системи керування  версіями часто зберігають копію файлу в певний момент часу разом з історією ревізій, і їх доводиться відтворювати (або перегортати), щоб відновити певну версію файлу. Git може робити все це швидше, оскільки він завжди знає повний вміст будь-якої версії файлу.

Іншими словами, у дивному способі роботи Git'а історію файлу можна обчислити, відстежуючи зміни у вмісті, або у блобах, а не у файлах.

Імена файлів розглядаються як метадані, відмінні від вмісту файлів, і зберігаються в об'єктах дерева та змістах (індексах). Вміст дерева підкаталогів .git зовсім не схожий на робочі каталоги, які вони представляють. Це повністю відрізняється від того, як налаштовано старіші системи керування версіями, такі як RCS або CVS.

Давайте подивимося, що це означає на практиці. 

Git-комміти - це, як правило, всі зміни для логічного групування (особливості, виправлення помилки тощо), включно зі змінами у всіх необхідних файлах.

Наприклад, за допомогою системи керування версіями RCS ви можете це зробити так:

$ rcs co src_slct.c

$ rcs co src_slct.dlg

$ rcs co src_slct.hlp

$ rcs co product_manual.doc

Переглянути файли, які потрібно доопрацювати. Потім ви відредагуєте їх, щоб виправити помилку або реалізувати функцію. Нарешті, ви можете перевірити їх знову за допомогою:

$ rcs ci srv_slct.c

$ rcs ci srv_slct.dlg

$ rcs ci srv_slct.hlp

$ rcs ci product_manual.doc

У RCS або інших подібних системах керування версіями необхідно використовувати теги, щоб згрупувати ці зміни разом. Якщо хтось знаходиться в середині процесу реєстрації і починається збірка системи, збірка може завершитися невдало. Для відкату змін потрібно знайти всі файли з однаковими тегами. Якщо хтось неправильно позначив одне з оновлень, відкотити зміни буде майже неможливо.

Для порівняння, в Git'і ви можете відредагувати файли, щоб виправити помилку або реалізувати функцію, а потім зробити це:

$ git add srv_slct.c

$ git add srv_slct.dlg

$ git add srv_slct.hlp

$ git add product_manual.doc

$ git commit -s

Крок git commit містить нові версії всіх чотирьох файлів. Відновлення змін, якщо було виявлено проблему, передбачає лише видалення комміту. 

--------------------------------------------Комміт vs. Публікація-------------------------------------------

Етапи коммітів та публікації у Git'і досить чітко розмежовані, порівняно з іншими системами керування версіями. 

Комміт – це локальний процес; це просто збереження поточного стану файлів вашого робочого проєкту у вашому локальному репозиторії, таким чином встановлюючи зручний маркер в історії розробки. Ви самі вирішуєте, чи будете ви часто коммітити невеликі зміни, чи рідко, але з великими наборами змін. 

Публікація означає надання доступу до ваших змін шляхом їх оприлюднення. Це можна зробити, виклавши або дозволивши іншим забирати ваш комміт, або за допомогою патчів. Це ефективно заморожує історію репозиторію. 

Комміт не вимагає доступу до мережі. Ви можете реорганізувати свої комміти у робочому репозиторії, перш ніж публікувати їх. Ви можете вибирати пункти для публікації з обережністю, щоб вони були логічними і чітко визначеними. 

------------------------------------------Апстрим та даунстрим----------------------------------------------

Батьківський репозиторій часто вважається апстрим (висхідним), а репозиторій, над яким ви працюєте, колись клонований з батьківського, часто вважається даунстрим (низьхідним). 

Знову ж таки, в самому Git'і немає нічого, що робить це розмежування подібним до відносин сервер / клієнт, оскільки Git має принципово однорангову архітектуру.

Концептуально, будь-який репозиторій, до якого ви надсилаєте зміни, вважається апстрим; будь-який репозиторій, який базується на вашому, вважається даунстрим.

Може бути кілька рівнів, якщо в одному з них є піддерева або фідери. Один репозиторій може мати як апстрим, так і даунстрим зв'язки. Наприклад, він може бути фокусом певної підсистеми, і весь репозиторій проєкту може бути апстрим, тоді як окремі підпроєкти можуть бути даунстрим. 

------------------------------------Розгалуження (Forks)----------------------------------------------------

Проєкт розгалужується (форкується), коли хтось бере весь проєкт і йде в іншому напрямку. Це іноді називають створення гілок. Однак у Git'і цей термін має інше семантичне значення, оскільки в межах одного репозиторію може бути декілька гілок. 

Технічно, кожного разу, коли ви клонуєте репозиторій за допомогою Git'а, ви створюєте розгалуження (форк). Але це не означає, що це будуть постійні розгалуження..

Існує ряд причин, з яких проєкт може розгалузитися (форкуватись). Серед розробників можуть виникати суперечки щодо напрямку проєкту або питань ліцензування, можуть виникати політичні та особисті конфлікти, такі як часті випадки, коли провідний мейнтейнер не реагує на запити. 

Що робить Git таким корисним, так це те, що його потужні можливості злиття роблять чудодійні гілки (форки) досить простим. Щоразу, коли гілка зливається з основним репозиторієм, розгалуження виліковується. Навіть досить старі розгалуження часто можна легко і просто об'єднати назад. 

-------------------------------------------Лабораторна 5.1 Важливі риси Git’а--------------------------------

Які риси Git'у відрізняють його від більшості, якщо не від усіх інших систем керування версіями? 

Розв’язок 5.1 
Наведений список, звісно, неповний і навіть дискусійний. Будь ласка, подумайте про додаткові аспекти. 

Git не засновується на файлах як базових одиницях. Натомість, основними одиницями зберігання є двійкові блоби. Якщо один і той самий файл з'являється у кількох місцях проєкту, для зберігання його вмісту потрібен лише один блоб.  
Більшість (але не всі) систем керування версіями мають центральний репозиторій, який є авторитетним. У Git'і всі репозиторії, незалежно від їхнього розташування чи власника, по суті однакові. Лідерство та авторитет визначаються за згодою.  
Git від самого початку був розроблений для розподіленої розробки, а не еволюціонував для роботи з нею. Таким чином, він завжди наголошував на мінімізації розмірів і швидкості передачі даних і був повністю побудований в інтернеті. 
Робота з кількома гілками, а також злиття (merge), перебазування (rebase) та розгалуження (fork) завжди були органічними рисами.  
Можливість робити комміти (перевірка змін) і публікація (надання їм широкого доступу) є цілком окремими етапами за задумом. 
Інші риси, такі як використання поділу навпіл (бісекції) для пошуку та виправлення проблем, є досить інноваційними та унікальними. 


