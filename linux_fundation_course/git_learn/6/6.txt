------------------------------Огляд розділу------------------------------------------

У цьому розділі описано основні команди та процедури при використанні Git'а; навіть звичайний користувач повинен засвоїти ці кроки.

Коли настає час внести зміни у вміст проєкту, розробник, який використовує Git, коммітить один або кілька змінених файлів. Кожен комміт ідентифікується 40-символьним шістнадцятковим хешем. Для зручності їх можна вказувати значно коротшими абревіатурами. У будь-якому місці можна також вказати теги. Це прості рядки символів, які є більш описовими і на які легше посилатися. Ви можете повернутися до будь-якого попереднього комміту або тегу за допомогою команди git checkout. За допомогою git diff легко вивчити історію проєкту і порівняти будь-які два комміти або теги. За необхідності можна повернутися до будь-якої попередньої стадії за допомогою однієї команди, а також відмовитися від поганого комміту. Блеймінг (звинувачення) дозволяє точно бачити, коли конкретні файли і рядки були змінені, а також коли і ким. Нарешті, використання технології поділу навпіл (бісекції) Git'а дозволяє точно визначити, який саме комміт спричинив проблеми.

------------------------------Навчальні цілі-----------------------------------------

Після опанування цього розділу, ви зможете:

Розуміти, що таке комміти і які стратегії можна використовувати для їх створення.
Пояснити роль шістнадцяткових ідентифікаторів та використання зручних тегів. 
Переглядати історію коммітів проєкту.
Повертатися (реверт) до попереднього стану і скидати (резет) комміти. 
Очищати репозиторій та зменшувати його розмір без втрати інформації.
Вивчати файли і рядки у файлах, щоб дізнатися, коли вони були додані або змінені і ким. 
Використовуйте поділ навпіл (бісекцію), щоб швидко виявити, коли була внесена помилка. 

--------------------------Як робити комміти------------------------------------------

Процес внесення коммітів знайомий з інших систем керування версіями. Однак спосіб, у який Git обробляє цей процес, дуже специфічний.

Коли виконується комміт, з файлів в змісті (індексі) створюється об'єкт комміту, і цей об'єкт поміщається в сховище об'єктів. Самі файли знаходяться у сховищі об'єктів вже тоді, коли вони розміщені в змісті (індексі).

Будь-які нові файли з часу останнього комміту призводять до появи нових блобів, а нові каталоги - до появи нових дерев; будь-який незмінний об'єкт просто використовується повторно. Таким чином, потрібне мінімальне нове сховище. Крім того, цей процес відбувається дуже швидко, оскільки не потрібно порівнювати блоби безпосередньо. Все, що потрібно зробити Git'у - це порівняти їхні шістнадцяткові ідентифікатори, щоб побачити, чи вони ідентичні. Зокрема, якщо хеш, що описує каталог, не змінився, то нічого не змінилося і в жодному з його підкаталогів.

Комміти пов'язані між собою деревом предків. Пізніше, коли ми будемо обговорювати розгалуження і злиття, ми побачимо, що це може бути складніше, ніж простий спуск через покоління.

Як часто ви будете вносити комміти - це ваше рішення. Вам слід вибирати чітко визначені моменти, але чи робити багато дрібних коммітів, чи менше великих - це ваш вибір. Зауважте, однак, що Git дуже ефективно працює з великою кількістю невеликих коммітів, а використання інструменту поділу навпіл (бісекції), про який ми поговоримо далі, може пришвидшити пошук точок, де були внесені помилки та регресії.

Зробити комміт можна кількома способами.

Припустимо, ви змінили кілька файлів (тобто вони на стадіюванні), але ви хочете закоммітити зміни лише в одному файлі:

 $ git commit -s file1

Якщо ви хочете закоммітити всі зміни, скористайтеся будь-якою з цих форм:

$ git commit -s

$ git commit ./ -s

$ git commit -a -s

$ git diff

покаже всі відмінності між вашими робочими каталогами і тим, що було закоммітино раніше. Після того, як ви виконаєте комміт, він не покаже жодних відмінностей.

---------------------------------Визначники та теги--------------------------------------

Щоразу, коли ви робите комміт, Git присвоює йому унікальне 160-бітове 40-символьне шістнадцяткове хеш-значення. Хоча ви можете посилатися на комміти з такими значеннями, це, звісно, громіздко. Наприклад, якщо взяти приклад з репозиторію коду ядра Linux, ми можемо переглянути історію коммітів з:

$ git log | grep "^commit" | head -10
commit 56b24d1bbcff213dc9e1625eea5b8e13bb50feb8
commit 5a45a5a881aeb82ce31dd1886afe04146965df23
commit ecade114250555720aa8a6232b09a2ce2e47ea99
commit 2c4ea6e28dbf15ab93632c5c189f3948366b8885
commit 106e4da60209b508894956b6adf4688f84c1766d
commit 4b050f22b5c68fab3f96641249a364ebfe354493
commit 84c37c168c0e49a412d7021cda3183a72adac0d0
commit 0acf611997d9d05dbfb559c3c6e379c861eb5957
commit 434fd6353b4c83938029ca6ea7dfa4fc82d602bd
commit 85298808617299fe713ed3e03114058883ce3d8a

Якщо ви хочете послатися на певний комміт або повернутися до нього, вводити такий довгий рядок, звичайно, буде нелегко. Однак, ви можете створити тег і використовувати його замість цього.

Тоді можна зробити так:

$ git tag ver_10 08d869aa8683703c4a60fdc574dd0809f9b073cd

Або навіть краще:

$ git tag ver_10 08d869

Якщо у другому прикладі ви використали досить довгу частину 40-символьного рядка, щоб посилання було унікальним, то короткої версії буде достатньо.

git tag створює тег або анотований тег (текстовий рядок, який посилається на об'єкт комміту). Тег розміщується в .git/refs/tags , якщо це не анотований тег, в цьому випадку тег створюється як об'єкт, в сховищі об'єктів:
 
Команда	       Вихідний файл	Зміст	  Ланцюжок коммітів	       Посилання
git tag	         Без змін	  Без змін	       Без змін	             Створено новий тег


Ми поговоримо про перевірку пізніше, але все, що вам потрібно зробити, щоб повернутися до точки розробки, позначеної ver_10, ось: 

$ git checkout ver_10

-----------------------------------------Перегляд історії коммітів (1)-----------------------------------------


Історію коммітів у Git'і легко відобразити за допомогою команди git log. Наприклад, розглянемо наступний скрипт, який створює репозиторій, а потім додає певні файли, змінює їх і вносить чотири комміти:

​#!/bin/bash

rm -rf git-test
mkdir git-test

cd git-test
git init

git config user.name "A Smart Guy"
git config user.email "asmartguy@linux.com"

echo file1 > file1
git add file1
git commit -s -m "Це перший комміт"

echo file2 > file2
git add file2
git commit . -s -m "Це другий комміт"

echo file3 > file3
echo another line for file3 >> file3
git add .
git commit . -s -m "Це третій комміт"

echo another line for file2 >> file2
git add .
git commit -a -s -m "Це четвертий комміт"

Якщо ми потім переглянемо журнал, то побачимо:

​$ git log

commit 4b4bf2c5aa95b6746f56f9dfce0e4ec6bddad407
Author: A Smart Guy <asmartguy@linux.com>
Date: Thu Dec 31 13:50:15 2009 -0600

Це четвертий комміт

commit 55eceacc9ab2b4fc1c806b26e79eca4429d8b52a
Author: A Smart Guy <asmartguy@linux.com>
Date: Thu Dec 31 13:50:15 2009 -0600

Це третій комміт

commit f60c0c21764676beca75b7edc2f5f5e51b5dd404
Author: A Smart Guy <asmartguy@linux.com>
Date: Thu Dec 31 13:50:15 2009 -0600

Це другий комміт

commit 712cbafa7ee0aaef03861b049ddc7865220b4e2c
Author: A Smart Guy <asmartguy@linux.com>
Date: Thu Dec 31 13:50:15 2009 -0600

Це перший комміт

-------------------------------------------------Перегляд історії коммітів (2)--------------------------------------

Комміти показані у зворотному порядку введення. Можна зробити ще коротше: 

$ git log --pretty=oneline

4b4bf2c5aa95b6746f56f9dfce0e4ec6bddad407 Це четвертий комміт
55eceacc9ab2b4fc1c806b26e79eca4429d8b52a Це третій комміт
f60c0c21764676beca75b7edc2f5f5e51b5dd404 Це другий комміт
712cbafa7ee0aaef03861b049ddc7865220b4e2c Це перший комміт

Також можна переглянути актуальні патчі, зроблені за допомогою опції -p, і можна переглянути лише частину історії, вказавши певний комміт, як у:

​$ git log -p f60c

commit f60c0c21764676beca75b7edc2f5f5e51b5dd404
Author: A Smart Guy <asmartguy@linux.com>
Date: Thu Dec 31 13:50:15 2009 -0600

Це другий комміт

diff --git a/file2 b/file2
new file mode 100644
index 0000000..6c493ff
--- /dev/null
+++ b/file2
@@ -0,0 +1 @@
+file2

commit 712cbafa7ee0aaef03861b049ddc7865220b4e2c
Author: A Smart Guy <asmartguy@linux.com>
Date: Thu Dec 31 13:50:15 2009 -0600

Це перший комміт

diff --git a/file1 b/file1
new file mode 100644
index 0000000..e212970
--- /dev/null
+++ b/file1
@@ -0,0 +1 @@
+file1

Існує багато інших варіантів git log , які ви можете переглянути за допомогою git help log або man git log.

----------------------------------------Скасування (reverting) та скидання (resetting) коммітів-------------------------------------------

Час від часу ви будете усвідомлювати, що здійснили зміни не дуже правильно. Можливо, ви внесли зміни, які не повинні були робити, або взяли на себе зобов'язання передчасно.

Ви можете відмовитися від певного зобов'язання: 

$ git revert commit_name

де commit_name може бути вказано різними способами і не обов'язково має бути найсвіжішим.

Комміти можна розмежовувати за допомогою:

HEAD: найсвіжіший комміт
HEAD~: попередній комміт (батько HEAD)
HEAD~~ або
HEAD~2: дідусь або бабуся HEAD
{hash number}: конкретний комміт за повним або частковим sha1-хеш-номером 
{tag name}: назва для комміта
Зауважте, що git revert вносить до нового комміту набір змін, тобто відмінений патч як додатковий комміт. Це доречно робити, якщо хтось інший завантажив дерево, що містить зміни, які було відкореговано. Це змінить вашу робочу копію вихідних файлів.

Якщо коротко, git revert збирає і додає новий об'єкт комміту, встановлює йому HEAD і оновлює робочий каталог


 випадку, коли ви єдиний, хто бачив оновлений репозиторій, краще скористатися командою git reset. Наприклад, якщо ви хочете відкликати останні два комміти, ви можете зробити так:

$ git reset HEAD~2

Це не змінить вашу робочу копію вихідних файлів. Вона просто змінить місцями комміти і зробить так, щоб зміст (індекс) відповідав вказаному комміту.

ри використанні будь-якої з опції--soft, --mixed, --hard, --merge або --keep, поведінка відрізняється. У цьому випадку посилання HEAD у поточній гілці також буде встановлено на вказаний комміт, додатково змінюючи зміст (індекс) та вихідні файли відповідно:

--soft: просто переміщує поточну гілку до об'єкта попереднього комміту (зміст (індекс) у цьому випадку не змінюється)
--mixed (за замовчуванням): також оновлює  зміст (індекс) відповідно до нового заголовка (все знімається зі стадіювання) 
--hard: те саме, що й --mixed, але також оновлює робочий каталог відповідно до нового заголовка (не редагує ваші файли).
Припустимо, що ви несамовито кодуєте і розумієте, що ваші останні три комміти все ще в роботі, але все, що було до цього, має бути доступним для інших. Тоді вам слід створити нову робочу гілку work, відкинувши гілку main на три комміти назад:

$ git branch work
$ git reset --hard HEAD~3
$ git checkout work

яка відновлює гілку main до попереднього стану, залишаючи спекулятивну роботу в work, де ви продовжите гратись. Детальніше про гілки ми поговоримо пізніше.

-------------------------------------------------Прибирання» в репозиторії------------------------------------------------

Коли ваш проєкт зростає через серію коммітів, ваш репозиторій може збільшуватися у розмірі. Ви можете оптимізувати і стиснути репозиторій, скориставшись git gc: 

​$ du -shc .git

47M .
47M total

$ git gc

Counting objects: 8, done.
Compressing objects: 100% (8/8), done.
Writing objects: 100% (8/8), done.
Total 8 (delta 2), reused 0 (delta 0)

$ du -shc .git

29M .git
29M total

де gc означає «збір сміття». 

Ви також можете перевірити репозиторій на наявність певних типів помилок за допомогою команди git fsck. Найбільш ймовірними і нешкідливими помилками, які вона знайде, будуть об'єкти, що бовтаються; хоча вони іноді бувають корисними для відновлення пошкоджених репозиторіїв, їх зазвичай можна безпечно видалити за допомогою git prune, як це зроблено тут:

$ git prune -n
$ git prune

де перша команда просто перевіряє, що буде зроблено, і якщо вас це влаштовує, ви можете віддати другу команду очищення. 

--------------------------------------Хто винний?-------------------------------------------

Можна призначити відповідальних за певний набір рядків у файлі.

Наприклад, використовуючи file2 з попереднього прикладу:

​$ git blame file2

f60c0c21 (A Smart Guy 2009-12-31 13:50:15 -0600 1) file2
4b4bf2c5 (A Smart Guy 2009-12-31 13:50:15 -0600 2) another line for file2

показує відповідальний комміт та автора. Можна вказати діапазон рядків та інші параметри для пошуку.

Наприклад, для складнішого файлу у вихідному коді ядра Linux:

c7:/usr/src/linux>git blame -L 3107,3121 kernel/sched/core.c​

e220d2dc kernel/sched.c (Peter Zijlstra 2009-05-23 18:28:55 +0200 3107)

e418e1c2 kernel/sched.c (Christoph Lameter 2006-12-10 02:20:23 -0800 3108) #ifdef CONFIG_SMP

6eb57e0d kernel/sched.c (Suresh Siddha 2011-10-03 15:09:01 -0700 3109) rq->idle_balance = idle_cpu(cpu);

-------------------------------Поділ навпіл (бісекція) (1)-----------------------------------

Припустимо, у вас була версія коду, яка працювала, а тепер, через багато версій (і коммітів), ви виявили, що вона більше не працює.

Git має можливість поділити навпіл (бісектувати), щоб швидко знайти набір змін, який все зіпсував. Кількість кроків не перевищує логарифм за основою 2 від кількості коммітів, що набагато швидше, ніж при звичайному переборі. Іншими словами, якщо погана зміна була зроблена десь в останніх 1024 коммітах, ви можете знайти її не більше ніж за 10 кроків поділу навпіл (бісекції).

Спочатку вам потрібно зробити:

$ git bisect start
$ git bisect bad
$ git bisect good V_10

де передбачається, що поточний комміт поганий, а версія V_10 відома як хороша. Після цього Git залишить вас на комміті на півдорозі між цими двома версіями. Після цього ви тестуєте код, щоб перевірити, чи помилка все ще там.

Якщо так, ви вводите код:

$ git bisect bad

Якщо в коді ще немає помилки, ви вводите:

$ git bisect good

Ви продовжуєте це ітеративно, поки не знайдете баг.

Потім ви вводите:

$ git bisect reset

щоб повернутися до поточного робочого стану.

-----------------------------------------Поділ навпіл (бісекція) (2)-----------------------------------

Для робочого прикладу спробуємо репозиторій ядра Linux:

$ git bisect start
$ git bisect bad
$ git bisect good v2.6.30

Bisecting: 16539 revisions left to test after this
[b4f3fda5d475931d596d5cf599a193f42b857594] Staging: hv: coding style cleanup of include/HvVpApi.h

$ git bisect bad

Bisecting: 8270 revisions left to test after this
[0de4adfb8c9674fa1572b0ff1371acc94b0be901] Blackfin: fix accidental reset in some boot modes

$ git bisect good

Bisecting: 4136 revisions left to test after this
[b9caaabb995c6ff103e2457b9a36930b9699de7c] Merge branch 'main' of
git://git.kernel.org/pub/scm/linux/kernel/git/holtmann/bluetooth-next-2.6
.........

$ git bisect good

Bisecting: 60 revisions left to test after this
[5d48a1c20268871395299672dce5c1989c9c94e4] Staging: hv: check return value of device_register()
........

/usr/src/GIT/work>git bisect bad
Bisecting: 3 revisions left to test after this
[b57a68dcd9030515763133f79c5a4a7c572e45d6] Staging: hv: blkvsc: fix up driver_data usage

$ git bisect good

Bisecting: 1 revisions left to test after this
[511bda8fe1607ab2e4b2f3b008b7cfbffc2720b1] Staging: hv: add the Hyper-V virtual network driver

$ git bisect good

Bisecting: 0 revisions left to test after this
[621d7fb7597e8cc2e24e6b0ca67118b452675d90] Staging: hv: netvsc: fix up driver_data usage

$ git bisect reset

Якщо є можливість написати скрипт, який перевіряє поточну версію на наявність помилки, процес стає ще простішим.

Припустимо, ви написали скрипт my_script.sh, який повертає 0, якщо поточна версія хороша, і будь-яке значення від 1 до 127, якщо вона погана. Тоді, після ініціалізації поділу навпіл (бісекції) з хорошою і поганою версією, ви можете просто зробити:

$ git bisect run ./myscript.sh

і процес завершиться, коли буде знайдено баг. 

Ви можете відтворити історію поділу навпіл (бісекції) за допомогою git bisect log або git bisect visualize.

Якщо ви робите невеликі інкрементні набори змін, баги можна знайти дуже швидко за допомогою поділу навпіл (бісекції). У коммітах з великою кількістю змін буде досить багато місць, які, можливо, доведеться перевіряти навіть після того, як ви визначите останню робочу версію і першу несправну.

-----------------------------------------------Лабораторна 7.1. Поділ навпіл (бісекція) з Git---------------------------------------

Завдання 7.1: Поділ навпіл (бісекція) з git 

1. Спочатку ініціалізуйте репозиторій, налаштувавши ваше ім'я, адресу електронної пошти тощо.  

2. Потім зробіть значну кількість коммітів, скажімо, 64. Кожен комміт повинен додавати файл. В одному з коммітів файл повинен містити рядок BAD. Ми будемо інтерпретувати це як введення вади. 

3. Тепер запустіть процедуру git bisec, позначивши останній коміт командою  

$ git bisect bad 

а перший 

$ git bisect good 

Подивіться, скільки бісекцій потрібно, щоб знайти ту, яка внесла ваду, тобто файл з BAD. 

4. Ви можете зробити це вручну або скористатися процедурою git bisect run  ... зі скриптом, щоб зробити це автоматично. 

5. Закінчивши, перевірте історію вашої бісекції за допомогою git bisect log. 

Розв’язок 7.1 

1. 

# Ініціалізуйте репозиторій, введіть ім’я, адресу електронної пошти до файлу .config 

echo -e "\n\n************* СТВОРЕННЯ РЕПОЗИТОРІЯ ТА КОНФІГУРАЦІЯ\n\n" 

rm -rf git-test ; mkdir git-test ; cd git-test 
git init 
git config user.name "A Smart Guy" 
git config user.email "asmartguy@linux.com" 

2. 

echo -e "\n\n*************     СТВОРЕННЯ КІЛЬКОХ ФАЙЛІВ ТА ДОДАВАННЯ " 
echo -e "                      ЇХ ДО ПРОЄКТУ І КОММІТ\n\n" 
n=0 
while [ $n -lt 64 ] ; do 
    n=$(($n+1)) 
    file=file$n 
    echo file > $file  
    if [ "$n" == "19" ] ; then 
        echo BAD >> $file 
    fi 
    git add $file 
    git commit $file -s -m"$file" 
    git tag $file 
    echo I added and committed $file 
done 

echo -e "\n\n************* Я ВНЕСУ РЯДОК З ВАДОЮ ДО file19\n\n" 

3. 

echo -e "\n\n************* ЗАПУСК БІСЕКЦІЇ\n\n" 

git bisect start 
git bisect bad 
git bisect good file1 

echo -e "\n\n************* ПОШУК ФАЙЛУ З ВАДОЮ\n\n" 

echo -e "\n\n************* ПРОВЕДЕННЯ БІСЕКЦІЇ ВРУЧНУ\n\n" 

over=0 
while [ "$over" == "0" ] ; do 
    if [ "$(grep BAD file*)" == "" ] ; then 
        git bisect good | tee gitout 
    else 
        git bisect bad | tee gitout 
    fi 
    if [ "$(grep 'revisions left' gitout)" == "" ] ; then 
        over=1 
        echo "****************** ВАДУ ЗНАЙДЕНО!" 
    fi 
done 

4. 

echo -e "\n\n*************** НАЛАШТУВАННЯ ТЕСТОВОГО СКРИПТА \n\n" 

cat <<EOF > my_script.sh 
#!/bin/bash 
if [ "\$(grep BAD file*)" == "" ] ; then 
    exit 0 
fi 
exit 1 
EOF 
chmod +x my_script.sh 

# Поверніться до початкового стану 

git reset 

git bisect start 
git bisect bad file64 
git bisect good file1 

# Запустіть автоматичний скрипт

git bisect run ./my_script.sh 

5. 

# Перегляньте лог

git bisect log 

 

Ви можете завантажити скрипт з переліченими кроками, наведеними вище: 
s_07/lab_bisect.sh 
до вашого файлу з розв’язком. 
Перегляньте, будь ласка, SOLUTIONS/s 07/lab_bisect.sh 

------------------------------------------