У цьому розділі ми розглянемо повний приклад: 

Запуск проєкту на основі Git'а.
Додавання до нього файлів та ресурсів.
Внесення змін до робочої копії програмного забезпечення. 
Внесення їх до репозиторію і, таким чином, надання доступу до них іншим розробникам. 
У підрозділах ми детально розглянемо всі ці кроки. 

------------------------------------------------------------------------------------------------

Опанувавши цей розділ, ви будете:

Розуміти, як отримати список основних команд Git'а та довідку щодо їх використання.
Виконувати простий, але ґрунтовний приклад створення проєкту, додавання до нього компонентів, їх модифікацію та оновлення репозиторію, в якому міститься проєкт.
Переглядати статус та історію проєкту. 

------------------------------------------------------------------------------------------------

Ви можете побачити версію Git'а, яку ви встановили: 

$ git --version

git version 2.27.0

Детальну довідкову інформацію у вигляді man-сторінки можна отримати про будь-яку підкоманду, виконавши: 

$ git help [subcommand]

Наприклад, наступні два оператори дають однаковий результат: 

$ git help status

$ man git-status

Ви можете отримати базовий список команд Git'а, просто набравши git, отримаєте ось такий список (див. скріншот): 

------------------------------------------------------------------------------------------------

У наведеному списку застосовуються лише декілька глобальних опцій, які починаються з префікса --. Багато підкоманд мають власні опції, які включено до [ARGS]. 

Якщо ви не можете втриматися від перегляду повнішого набору команд, це можна зробити ось так: 

$ git help --all

Цей довгий список може здатися досить страшним, але деякі з команд насправді призначені для експертного використання і рідко застосовуються, або їх ефективніше викликати за допомогою комбінаторних команд скорочення.

Крім того, існує кілька графічних інтерфейсів до Git'а, які дозволяють не називати всі додаткові функції.

------------------------------------------------------------------------------------------------

Історично новий репозиторій завжди створювався з початковою гілкою під назвою master. Однак у багатьох проєктах ця назва застаріла і замінена на main.

Причини цієї зміни та інших змін у термінології, як-от застарілість словосполучень «чорний список» і «білий список», пояснюються у статті «Список замін слів», створеній Ініціативою з інклюзивного неймінгу.

Технічно, ця гілка main може мати будь-яку назву, оскільки в цій авторитетній гілці немає нічого особливого з точки зору структури. Однак, Git повинен мати назву за замовчуванням для нових репозиторіїв, і деякі хостинги мають вимоги, які важко обійти.

GitHub наполегливо рекомендує змінити цю угоду про імена і надав інструкції про те, як створювати нові репозиторії, а також перейменовувати старі, щоб основною гілкою була main.

Якщо ви створюєте новий репозиторій, найпростіший спосіб зробити це з самого початку - зробити щось на кшталт:

$ git init
$ git checkout -b main

Для вже наявних репозиторіїв ви можете перейменувати як локальну гілку, так і віддалену гілку на сервері з:

$ git checkout master
# Змінити локальну назву
$ git branch -m master main

# Змінити віддалену назву
$ git push -u origin main
$ git symbolic-ref refs/remotes/origin/HEAD refs/remotes/origin/main

# Підтвердити імена!
$ git branch -a

Залежно від налаштувань віддаленого сервера (наприклад, GitHub) це може спрацювати, а може і не спрацювати. Простіший підхід - не видаляти гілку master, а просто скопіювати її в main і працювати звідти, як і раніше:

$ git checkout master
$ git branch main
$ git checkout main
$ git push -u origin main

а потім просто ігноруйте гілку master надалі. 

Надалі ми будемо вважати, що назва гілки, яка відіграє цю роль, main, і що всі необхідні зміни були внесені. 

----------------------------------------------------------------------------------------------------------------

Давайте розберемося, як працює Git і наскільки він простий у використанні. Наразі ми просто створимо власний локальний проєкт.

Спочатку ми створимо робочий каталог, а потім ініціалізуємо Git для роботи з ним:

​$ mkdir git-test
$ cd git-test
$ git init

Під час ініціалізації проєкту створюється каталог .git, який міститиме всю інформацію про керування версіями. Основні каталоги, що входять до складу проєкту, залишаються недоторканими. 

Початковий вміст цього каталогу має вигляд:

$ ls -l .git

total 40
drwxrwxr-x 7 coop coop 4096 Dec 30 13:59 ./
drwxrwxr-x 3 coop coop 4096 Dec 30 13:59 ../
drwxrwxr-x 2 coop coop 4096 Dec 30 13:59 branches/
-rw-rw-r-- 1 coop coop   92 Dec 30 13:59 config
-rw-rw-r-- 1 coop coop   58 Dec 30 13:59 description
-rw-rw-r-- 1 coop coop   23 Dec 30 13:59 HEAD
drwxrwxr-x 2 coop coop 4096 Dec 30 13:59 hooks/
drwxrwxr-x 2 coop coop 4096 Dec 30 13:59 info/
drwxrwxr-x 4 coop coop 4096 Dec 30 13:59 objects/
drwxrwxr-x 4 coop coop 4096 Dec 30 13:59 refs/

Пізніше ми опишемо вміст цього каталогу та його підкаталогів; здебільшого вони починаються порожніми.

Далі ми створюємо файл і додаємо його до проєкту:

​$ echo some junk > somejunkfile
$ git add somejunkfile

Ми можемо бачити поточний стан нашого проєкту за допомогою:

​$ git status

# На гілці master
#
# ініціалізувати комміт
#
# Зміни, які будуть коммітитись:
#   (use "git rm --cached <file>..." to unstage)
#
#       новий файл: somejunkfile

Зверніть увагу, що він повідомляє нам, що наш файл знаходиться на стадії становлення (додавання), але ще не закоммітений.

Давайте скажемо Git'у, хто відповідає за цей репозиторій:

$ git config user.name "Another Genius"
$ git config user.email "a_genius@linux.com"

Це потрібно робити для кожного нового проєкту, якщо тільки він не визначений у глобальному файлі конфігурації.

Тепер давайте змінимо файл, а потім подивимося історію відмінностей:

​$ echo another line >> somejunkfile
$ git diff

diff --git a/somejunkfile b/somejunkfile
index 9638122..6023331 100644
--- a/somejunkfile
+++ b/somejunkfile
@@ -1 +1,2 @@
some junk
+another line

---------------------------------------------------------------------------------------------------------------------------------

Для того, щоб фактично закоммітити зміни в репозиторії, ми це робимо: 

$ git add somejunkfile
$ git commit -m "My initial commit"

Created initial commit eafad66: My initial commit
1 files changed, 1 insertions(+), 0 deletions(-)
create mode 100644 somejunkfile

Якщо ви не вкажете ідентифікаційне повідомлення, яке супроводжуватиме комміт за допомогою опції -m, ви перейдете до редактора, щоб внести туди якийсь вміст. Ви маєте зробити це, інакше комміт буде відхилено. Обраним редактором буде редактор, встановлений у вашій змінній оточення EDITOR, яку можна замінити значенням GIT_EDITOR.

Ви можете переглянути свою історію за допомогою:

$ git log

​commit eafad66304ebbcd6acfe69843d246de3d8f6b9cc
Author: A Genius <a_genius@linux.com>
Date: Wed Dec 30 11:07:19 2009 -0600

My initial commit

​і ви побачите інформацію, яку ви там отримали. Ви помітите довгий шістнадцятковий рядок, який є номером комміту. Це 160-бітний, 40-значний унікальний ідентифікатор, про який ми поговоримо пізніше. git дбає про цих звірів, а не про назви файлів.

Підпис коммітів
Важливо знати, хто відповідає за всі зміни в репозиторії, щоб відстежувати історію і розуміти, хто гарантує, що код, який вноситься до репозиторію, робиться з належним ліцензуванням і правом власності.

Найпростіше це зробити, додавши до комміту рядок Signed-off-by з опцією -s. Так ми могли б зробити:

$ git commit -s -m "My initial commit" 

І тоді отримаємо:

commit eafad66304ebbcd6acfe69843d246de3d8f6b9cc
Author: A Genius <a_genius@linux.com>
Date: Wed Dec 30 11:07:19 2009 -0600
    My initial commit
    Signed-off-by: Another Genius <a_genius@linux.com>

Зауважте, що особа, яка підписує зміни, не обов'язково має бути їх автором; це може бути супровідник або інший рецензент, але вона бере на себе необхідну відповідальність. Крім того, будь-яку зміну може підписувати більше ніж одна особа.

Тепер ви можете вільно змінювати вже наявні файли та додавати нові за допомогою git add. Але насправді зміни не будуть повністю розміщені у репозиторії, доки ви не зробите ще одну  операцію git commit.

Це було не так вже й важко. Але ми лише трошки намацали шлях.

-------------------------------------------------------------------------------------------------------------------------

Завдання 4.1: Налаштування репозиторія, внесення змін та коммітів 
За допомогою простої підмножини команд, які ми вже надали вам, ми створимо простий репозиторій. 

Спочатку ініціалізуйте сховище за допомогою git init. Потім додайте інформацію про автора та електронну пошту за допомогою git config.
Створіть кілька простих текстових файлів, додайте їх до репозиторія і закоммітьте за допомогою git add та  git commit.
Тепер змініть один з файлів і запустіть  git diff, щоб побачити відмінності між файлами вашого робочого проєкту і тим, що знаходиться в репозиторії.
Знову додайте змінений файл до репозиторія і знову запустіть  git diff. 
Нарешті, знову зробіть комміт, а потім, використовуючи git log, вивчіть свою історію. 
На різних етапах виконання всіх цих дій переглядайте вміст каталогу .git і дивіться, які файли змінюються, який їхній вміст тощо. Дізнайтеся якомога більше.

Розвʼзок 4.1 
1. 

# Налаштуйте каталог, в якому ми будемо працювати 

rm -rf git-test ; mkdir git-test ; cd git-test 

# Ініціалізуємо репозиторій і введемо наше ім'я та електронну пошту у файлі .config 

echo -e "\n\n********* СТВОРЕННЯ РЕПОЗИТОРІЯ ТА КОНФІГУРАЦІЯ \n\n" 

git init 
git config user.name "A Smart Guy" 
git config user.email "asmartguy@linux.com" 

2. 

echo -e "\n\n*********    СТВОРЕННЯ КІЛЬКОХ ФАЙЛІВ ТА ДОДАВАННЯ ДО ПРОЄКТУ І КОММІТ\n\n

# Створіть кілька файлів і додайте їх до проєкту 
# Ми зробимо це у вигляді двох коммітів, хоча можна було б зробити і в одному

echo file1 > file1 
git add file1 
git commit file1 -s -m "Це перший комміт" 

echo file2 > file2 
git add file2 
git commit . -s -m "Це другий комміт" 

3. 

# Змініть один з файлів і подивіться різницю з репозиторієм 

echo -e "\n\n************* ЗМІНІТЬ ОДИН З ФАЙЛІВ ТА ВИКОНАЙТЕ ОПЕРАЦІЮ DIFF\n\n" 

echo This is another line for file2 >> file2 
git diff 

4. 

# Тепер ставимо на стадіювання і знову порівнюємо

git add file2 
git diff 

5. 

echo -e "\n\n*************   ДОДАВАННЯ ЗМІНЕНИХ ФАЙЛІВ ТА НОВЕ ПОРІВНЯННЯ \n\n" 
echo -e "\n\n*************   КОММІТ ТРЕТІЙ РАЗ\n\n" 
# А тепер зберіть все в новому комміті

git commit . -s -m "Це третій комміт" 

echo -e" \n\n*************   ПЕРЕГЛЯД ІСТОРІЇ ПРОЄКТУ \n\n" 

#Перегляньте історію

git log 

 

Ви можете завантажити скрипт з переліченими кроками:  
s_04/lab_gitexample.sh 
до вашого файлу розв’язків. 
Перегляньте, будь ласка, SOLUTIONS/s 04/lab_gitexample.sh 

-------------------------------------------------------------------------------------------------------------------------









