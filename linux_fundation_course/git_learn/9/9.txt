-----------------------------Навчальні цілі------------------------------

Після опанування цього розділу, ви зможете:

Розуміти, що означає об'єднання роботи одного розробника у певну гілку репозиторія. 
Пояснити, чому злиття (merge) є зворотним процесом до розгалуження. 
Розуміти процес вирішення конфліктів злиття. 
Основні команди злиття (merge). 
Пояснити, як працює перебазування (rebasing).
Пояснити важливу відмінність між злиттям (merge) та перебазуванням (rebasing).

------------------------Що таке злиття (merge)?--------------------------

Усі системи керування версіями, окрім найпримітивніших, мають справу з проблемою злиття. Це трапляється, коли над проєктом одночасно працює кілька розробників, і виникає необхідність повернути їхні зміни в єдину кодову базу.

Якщо зміни не конфліктують між собою безпосередньо, тобто вони працюють над різними файлами або над різними частинами одних і тих же файлів, об'єднати роботу не складає особливих труднощів.

Наприклад, якщо є два набори змін, ви можете просто застосувати один, а потім інший; порядок не має значення. Єдине технічне уточнення полягає в тому, що після одного набору змін може відбутися зсув рядків, де має працювати другий набір змін через вставки або видалення, зроблені в першому наборі. Будь-яка розумна система керування версіями або менеджер виправлень може впоратися з такими простими зміщеннями.

Навіть у цьому простому випадку, коли набори змін не перетинаються, можуть виникнути тонші проблеми, які можуть бути помічені лише людиною. Ускладнення можуть легко виникнути, наприклад, якщо два різних набори змін намагаються виправити одну і ту ж помилку, але роблять це в різних місцях і різними методами.

У таких випадках використання методології Git'а, що передбачає наявність багатьох невеликих наборів виправлень і коммітів, у поєднанні з використанням таких інструментів, як поділ навпіл (бісекція), може допомогти швидкому вирішенню таких тонких проблем.

У випадку конфліктних наборів змін, Git був розроблений саме так, щоб мати потужні інструменти для розв’язання конфліктів. У цьому розділі ми розкажемо, як ці інструменти можна використовувати.

Злиття (merge) можна розглядати як процес, зворотній до розгалуження. Ми вже обговорювали, як Git обробляє відкриття нової гілки. Без ефективного автоматизованого процесу повторного приєднання ми б мали набагато слабшу систему керування версіями.

-----------------------------Команди злиття (1)--------------------------

Об'єднати гілку devel з поточною гілкою main дуже просто: 

$ git checkout main
$ git merge devel

де перший крок необхідний лише в тому випадку, якщо ви ще не працюєте над гілкою main.

Хоча це не є абсолютно обов'язковим, найкращою практикою є наведення порядку перед злиттям. Це означає, що потрібно закоммітити всі зміни, які були внесені, позбутися непотребу тощо. Це може допомогти мінімізувати подальшу плутанину. Ви можете перевірити свій поточний стан за допомогою команди:

$ git status

Якщо у вас не було конфліктів, попередня команда злиття (merge) видасть щасливий звіт, і ваша гілка main тепер містить все, що було у гілці devel; її було синхронізовано з поточною розробкою. Однак, давайте подивимося, що станеться, якщо злиття виявить конфлікт. 

Для цього ми створимо ідентичні гілки main і devel, за винятком того, що в основній гілці ми створимо файл file1, який містить один рядок, скажімо file901. У гілці devel цей файл має рядок file701. Виконавши зазначену вище процедуру злиття (merge), ми отримаємо результат: 

$ git merge devel

Auto-merged file1
CONFLICT (content): Конфлікт злиття у file1
Автоматичне злиття не вдалося; виправте конфлікти та закоммітьте результат. 

Перерахування файлів у робочій гілці за допомогою команди: 

$ git ls-files

file1
file1
file1
file2
file3

показує кумедний результат, коли file1 записано тричі!

----------------------------------Команди злиття (2)--------------------------------------

Якщо ми подивимося на вміст цього файлу після спроби злиття (merge), то побачимо цікавий результат: 

$ cat file1

<<<<<<< HEAD:file1
file901
=======
file701
>>>>>>> devel:file1

трьохсторонній diff показує причину.

Зауважте, що всі інші зміни в результаті злиття пройшли успішно. Команда злиття детально розповість вам про кожну проблему.

Існує два основних підходи до виправлення проблем. Перший - скасувати злиття за допомогою git reset, попрацювати над конфліктами у будь-якій з двох гілок доти, доки конфліктів у результаті злиття не буде, і спробувати ще раз.

Якщо ви наробили багато лиха передчасним або випадковим злиттям, легко повернутися до того, на чому ви зупинилися: ось так

$ git reset --hard main

Другий підхід - попрацювати над файлом спроби злиття, третьою копією, яка містить всі кумедні маркери. Ви можете редагувати його досхочу, щоб відобразити те, що має бути результатом злиття, а потім просто закоммітити  його: ​

$ git add file1
$ git commit -s -m "A message for the merge"
$ git ls-files

file1
file2
file3

Зверніть увагу, що дивна поява трьох версій файлу file1  зникла, і злиття завершено.

Який підхід ви оберете, залежить від розміру набору даних для злиття, кількості конфліктів, що виникають тощо і повністю залежить від вас. Кінцевий результат буде однаковим.

-----------------------------Перебазування (rebase) (1)-----------------------------------

Припустімо, що ви створили гілку розробки колись, і основна гілка, з якої ви починали, продовжує розвиватися одночасно з внесенням змін у вашу гілку розробки.

Зрештою, ви хочете об'єднати свою роботу з паралельними гілками розробки, але припустимо, що ваша робота ще не зовсім готова до прайм-тайму, але ви хочете отримати вигоду від іншої роботи, що ведеться в паралельній гілці.

Існує два основних методи, які можуть здатися схожими, але насправді є зовсім різними: злиття (merge) і перебазування (rebase).

Злиття (merge) просто означає залучення іншого (можливо, основного) репозиторія, що розвивається, час від часу. Будь-які конфлікти потрібно буде вирішувати як зазвичай.

Перебазування (rebase) - це зовсім інша процедура. Коли ви виконуєте цю процедуру, всі ваші зміни з моменту початкового відгалуження від іншої лінії розробки скасовуються, відгалуження приводиться до поточного стану, а потім ваші зміни переробляються так, щоб вони відповідали поточному стану.

Щоб навести конкретний приклад, уявімо, що ви працюєте над новою функцією для ядра Linux і почали роботу, коли ядро було випущено у версії 4.16. Поки ви щасливо пишете код, основне ядро продовжує розвиватися і виходить версія 4.17. Якщо ви зробите перебазування (rebase), ваші зміни і набір патчів буде переписано так, щоб вони застосовувалися до коду 4.17, а не до коду 4.16, що, сподіваємося, спростить ситуацію у майбутньому. Насправді, з часом ви можете зробити повторну збірку.

Кроки до перебазування (rebasing) дуже прості. Припустимо, в якийсь момент у минулому ви зробили так:

$ git checkout -b devel origin

де origin - це гілка віддаленого відстеження, як ми обговоримо пізніше (звичайно, ви можете використовувати і локальну гілку, але це, мабуть, буде менш реалістично). Потім ви вносите ряд змін до файлів проєкту і робите комміти у вашій гілці devel. Тим часом, гілка origin продовжує розвиватися.

Операція перебазування (rebase) починається з:

$ git checkout devel
$ git rebase main devel

---------------------------------Перебазування (rebase) (2)------------------------------

Коли ви це робите, кожен комміт, зроблений з початкової точки гілки, видаляється, але зберігається у .git/rebase-apply. Потім гілка devel переноситься до останньої версії origin, а потім кожна зміна застосовується до оновленої гілки.

Очевидно, що можуть виникнути конфлікти, і якщо їх буде знайдено, вам буде запропоновано вирішити їх так само, як ви це робили під час злиття. Під час виправлення конфліктів вам потрібно буде виконати git ad для оновлення змісту (індексу), а коли ви закінчите виправлення конфліктів, замість того, щоб робити комміт, виконайте наступне:

$ git rebase --continue

Якщо на якомусь етапі починається катастрофа, ви можете повернутися до того місця, де ви були до спроби перебазування за допомогою:

$ git rebase --abort

З перебазуванням (rebase) пов'язані потенційні проблеми, деякі з яких виникають через його оруелівську природу. Коли ви робите перебазування, ви змінюєте історію коммітів, оскільки зміни тимчасово видаляються, а потім повертаються назад. Це призводить щонайменше до кількох проблем: 

Ймовірно, ви тестували свою роботу в процесі її виконання, а гілка коду, з якою ви тестували, походить з більш ранньої точки гілки. Немає ніяких гарантій, що тільки тому, що все працювало раніше, коли ви тестували, воно буде працювати і надалі. Насправді, проблеми, що виникають, можуть бути дуже малопомітними. 
Можливо, ви виконували свою роботу як серію невеликих коммітів, це хороша практика, коли ви намагаєтеся визначити, де могли виникнути проблеми, наприклад, при використанні поділу навпіл (бісекції). Але тепер ви об'єднали роботу в один великий комміт. 
Якщо хтось інший користувався вашими напрацюваннями, наприклад, витягував зміни з вашого дерева, ви щойно висмикнули килимок з-під їхніх ніг. У цьому випадку багато розробників вважають перебазування страшним гріхом.
Якщо ви робите злиття (merge), а не перебазування (rebase), можуть виникнути інші проблеми, особливо якщо ви робите це часто або не в основні стабільні моменти розробки. Знову ж таки, історія може заплутати ваш проєкт. Яку б стратегію ви не обрали, продумайте все до дрібниць і робіть злиття або перебазування тільки на хороших, чітко визначених етапах розробки, щоб звести до мінімуму проблеми. 

Команда	Вихідні файли	Зміст (Index)	Ланцюжок коммітів	Посилання
git rebase	Без змін	Без змін	Комміт батьківської гілки перенесено до іншого комміту	Без змін

------------------------------Лабораторна 10.1. Розв’язання конфліктів злиття--------------

Завдання 10.1: Розв’язання конфліктів злиття 

Почніть роботу з репозиторіями main та devel з попереднього сеансу у гілках, або створіть їх заново.  
Внесіть зміни до гілки main, які конфліктують із змінами у гілці devel. Закоммітьте їх, а потім скористайтеся git merge, щоб об'єднати гілку devel з гілкою  main.  
Розв’яжіть конфлікти, або використавши git reset і змінивши одну з гілок, або змінивши конфліктні файли, а потім закоммітивши їх ще раз. 
Розв’язок 10.1 

1. Ви можете пропустити наступний крок, якщо використовуєте результати попередніх лабораторних. 

# Ініціалізуйте репозиторій, введіть ім’я, адресу електронної пошти до файлу .config 

echo -e "\n\n********* СТВОРЕННЯ РЕПОЗИТОРІЮ ТА КОНФІГУРАЦІЯ\n\n" 

rm -rf git-test ; mkdir git-test ; cd git-test 
git init 
git config user.name "A Smart Guy" 
git config user.email "asmartguy@linux.com" 

echo -e "\n\n********* СТВОРЕННЯ КІЛЬКОХ ФАЙЛІВ, ДОДАВАННЯ ЇХ ДО ПРОЄКТУ ТА КОММІТ\n

# Створіть кілька файлів, додайте їх до проєкту та закоммітьте 

echo file1 > file1 
echo file2 > file2 
git add file1 file2 
git commit . -s -m "Це наш перший комміт" 

# Створіть нову гілку розробки 

echo -e "\n\n**************** СТВОРЕННЯ НОВОЇ ГІЛКИ devel ***\n\n" 

git branch devel 

# Перевірте нову гілку

echo -e "\n\n***************ПЕРЕВІРКА ГІЛКИ devel ****\n\n" 

git checkout devel 

# Змініть файл та додайте ще один

echo another line >> file1 
echo file3 >> file3 

git add file1 file3 

echo -e "\n\n************* ПОРІВНЯННЯ\n\n" 
git diff 

echo -e "\n\n************* НОВИЙ КОММІТ\n\n" 

# А тепер зберіть всі зміни в новий комміт

git commit . -s -m "Це комміт до гілки devel" 

# Перелічьте файли

echo -e "\n\n перелічить файли, потім зробіть git ls-files\n\n" 

ls -l 
git ls-files 

# Тепер перервіте оригінальну гілку  

echo -e "\n\n************ ПЕРЕЛІЧУВАННЯ ГІЛОК ТА ПЕРЕВІРКА main **\n\n" 

git branch 
git checkout main 

# Перелічіть файли

echo -e "\n\n***************** перелічіть файли, потім зробіть git ls-files\n\n" 

ls -l 
git ls-files 

echo -e "\n\n***************** ПОКАЗАТИ ГІЛКУ\n\n" 

2. 

git branch 

# Змінінть щось в оригінальній гілці для створення конфлікту у гілці devel 

echo -e "\n\n*************** ЗМІНА ГІЛКИ MAIN ТА КОММІТ\n\n" 

echo different content >> file1 

# Додайте та перекоммітьте

git add file1 
git commit -s -m"нова зміна" 

git diff main devel 

# Спробуйте виконати злиття 

echo "\n\n************** СПРОБА ВИКОНАННЯ ЗЛИТТЯ \n\n" 

git merge devel 

echo "\n\n************* ЗЛИТТЯ НЕВДАЛЕ ****\n\n" 
echo "\n\n************* ВИПРАВТЕ file, потім додайте та закоммітьте\n" 
echo "\n\n************ У іншому вікні відредагуйте файл та щось тут надрукуйте\n\n"
read something 

3. 

git add file1 
git commit -s -m"нарешті правильно" 

git ls-files 
git diff 
git branch 

 

Ви можете завантажити скрипт з кроками, наведеними вище: 
s_10/lab_conflict.sh 
до вашого файлу розв’язків. 
Перегляньте, будь ласка, SOLUTIONS/s 10/lab_conflict.sh 

-------------------------------Завдання 10.2: Перебазування (rebase)---------------------------------

Завдання 10.2: Перебазування (rebase) 

Після того, як ви створили гілку розробки, внесіть якісь зміни в гілку main і повторно закоммітьте.  
Виконайте git log на гілці devel, щоб побачити історію коммітів. 
Перебазуйте гілку розробки за допомогою git rebase зі зміненої гілки main.
Знову виконайте git log у гілці devel, щоб показати історію коммітів, і знайдіть різницю. 
Розв’язок 10.2 

1.  Ви можете пропустити наступний крок, якщо використовуєте результати попередніх лабораторних або повторити перший крок з попередньої лабороторної.  

2. 

git branch 

# Порівняйте гілки

echo -e "\n\n****************** ПОРІВНЯННЯ ГІЛОК ****\n\n" 

git diff main devel 

# Отримайте лог гілки devel 

echo -e "\n\n****************** git log на гілці devel *** \n\n" 

git checkout devel 
git log 

3. 

# Внесіть зміни до гілки main 

echo -e "\n\n****************** Внесіть зміни до гілки main та закоммітьте\n\n" 
git checkout main 
echo something >> file4 
git add file4 
git commit -s -m"новий комміт до гілки main" 

# Виконайте перебазування

echo -e "\n\n******************* ПЕРЕБАЗУВАННЯ **********\n\n" 

git rebase main devel 

git branch 
git ls-files 

# Порівняйте гілки

echo -e "\n\n****************** ПОРІВНЯННЯ ГІЛОК ****\n\n" 

git diff main devel 

4. 

# Отримайте лог гілки devel 

echo -e "\n\n****************** git log на гілці devel *** \n\n" 

git checkout devel 
git log 

 

Ви можете завантажити скрипт з кроками, наведеними вище: 
s_10/lab_rebase.sh 
до вашого файлу з розв’язками.
Перегяньте, будь ласка, SOLUTIONS/s 10/lab_rebase.sh 
