----------------------------------Навчальні цілі-------------------------------------

Після опанування цього розділу, ви зможете:

Пояснити, що таке гілка, як їх створювати та переходити між ними. 
Зрозуміти різницю між назвою гілки та тегом.
Перерахувати всі доступні гілки та контролювати рівень деталізації.
Вийти з гілки.
Отримувати попередні версії файлів.

-------------------------------Що таке гілка?----------------------------------------

Трапляється так, що може виникнути необхідність відійти від основного напрямку розробки і створити незалежну гілку. Наприклад, коли виходить великий реліз продукту, вам може знадобитися створити гілку для супроводу і гілку для розробки.

Гілка супроводу може бути обмежена виправленням помилок і серйозних недоліків продуктивності, а також закриттям дірок у безпеці. Крім внесення цих змін, гілка розробки також міститиме нові можливості та оптимізації, не призначені для публічного релізу, доки не буде готова наступна основна версія продукту.

Ще одна причина підтримувати окрему гілку - ізолювати певну ділянку розробки або працювати над дуже серйозною помилкою, не обтяжуючись шумом, що створюється іншими одночасними змінами.

Що робить Git таким корисним, так це те, що, хоча процес розгалуження простий, зворотний процес злиття також простий, і вся інфраструктура була структурована з урахуванням цього. Ми обговоримо злиття в деталях пізніше.

Все це надихнуло те, як розвивалася спільнота розробників ядра Linux. Існує багато паралельних гілок для таких речей, як мережеві драйвери, мережа та USB. Насправді, з точки зору Git'а, гілка, яку підтримує Лінус Торвальдс, хоча вона є місцем збору змін і в деякому сенсі найважливішою гілкою, в технічному сенсі нічим не відрізняється від будь-якої іншої гілки. Її важливість є соціальною, політичною і тактичною, але не структурною.

Одна гілка може відстежувати іншу гілку, діючи при цьому незалежно. Це означає, що вона може бути в курсі змін в іншій гілці без необхідності починати все спочатку. Іншими словами, точка розгалуження може бути перенесена в майбутнє початкової диверсії. Таким чином, відмінності між паралельними гілками можуть бути якомога меншими, навіть якщо вони обидві розвиваються.

У проєкті може бути багато гілок в одному репозиторії, але у вас при цьому може бути одна активна (тобто поточна) гілка одночасно. Файли у ваших робочих каталогах - це файли з цієї гілки. Якщо ви перемкнете гілку, файли зміняться.

------------------------------Назви гілок vs. Теги---------------------------------

Іноді люди плутаються в різниці між назвами гілок і тегами. Насправді, можна використовувати один і той самий рядок для обох, оскільки вони працюють у різних просторах назв, але це вимагає певної обережності і не рекомендується для неспеціалістів.

Назва гілки представляє напрямок розвитку. Зазвичай основний напрямок розробки називають гілкою main, так вона називається за замовчуванням. З часом інші гілки народжуватимуться, отримуватимуть назви і розвиватимуться паралельно. Вони можуть мати такі назви, як develop, debug або stable.

Хоча вміст гілки буде змінюватися з плином часу і створенням нових коммітів, назва гілки зазвичай не змінюється, за винятком випадків, коли починається інша гілка.

Теги, з іншого боку, представляють стадію конкретної гілки у певний момент її історії. Якщо ви не хочете, аби вам зробили дуже боляче, ви ніколи не зміните назву тегу в майбутньому. Вони повинні бути незмінними.

Якщо дві гілки мають спільного пращура, вони матимуть спільні теги, які існували до їх відокремлення. Якщо дві паралельні гілки приймуть однакову назву для тегу після того, як вони відокремилися, процес злиття повинен буде впоратися з цим. Але пам'ятайте, що тег можна розглядати як псевдонім для одного з тих довгих шістнадцяткових рядків, які є основними ідентифікаторами коммітів. Коли ми будемо обговорювати злиття, ми розглянемо цю ситуацію.

-----------------------------Створення гілки---------------------------------------

Основною командою для створення нової гілки є:

$ git branch [branch_name] [starting_point]

Якщо ви не вкажете жодних аргументів, ви отримаєте список гілок, активна з яких буде позначена зірочкою. Дуже детальну історію гілок можна отримати за допомогою: 

$ git show-branch

Якщо ви створюєте нову гілку, ви повинні дати їй назву. Існують певні правила, такі як відсутність пробілів у назві, відсутність спеціальних або керівних символів, відсутність косої риски в кінці тощо. Будьте простішими. 

Гілка схожа на тег, але ви можете додавати до неї комміти.​

Команда	Вихідні файли	Зміст (Index)	Ланцюжок коммітів	Посилання
git branch	Без змін	Без змін	Без змін	Нова гілка створена у git/refs/heads.HEAD для нової гілки вказує на HEAD поточної гілки. Поточна гілка встановлюється на нову гілку.
Точкою відліку може бути будь-який комміт, якщо є тег, який його описує, ви можете використати його замість довгого рядка. Якщо ви не вкажете аргумент, буде створено копію активної гілки з моменту її останнього комміту. Отже, ви можете зробити так:

$ git branch devel

щоб створити нову гілку розробки поза основною.

Ви можете видалити гілку devel за допомогою:

$ git branch -d devel

яка не може бути поточною робочою гілкою.

Відновити випадково видалену гілку досить складно, хоча не завжди неможливо, тому будьте обережні.

--------------------------Перехід на гілку (checkout)--------------------------------

У процесі переходу (checkout) ви можете переключитися на іншу гілку. Якщо ви це зробите:

$ git checkout devel

ви перейдете до гілки розробки у попередньому прикладі, і вміст усіх файлів, які було змінено, буде змінено відповідно до цього. HEAD буде встановлено на верхній комміт гілки. 

Зауважте, що ви не втратили стару гілку. Вся інформація для повернення до неї все ще знаходиться у репозиторії. Все, що вам потрібно зробити, це:

$ git checkout main

і активну гілку буде скинуто (reset), а вміст файлів буде відновлено (revert). Це все також відбувається просто миттєво.

Команда	Вихідні файли	Зміст (Index)	Ланцюжок коммітів	Посилання
git checkout	Модифіковано відповідно до дерева коммітів, вказаного за ідентифікатором гілки або комміту; невідстежувані файли не видалено.	Без змін	Без змін	Поточна гілка скидається (reset) до перевіреної. HEAD (у .git/HEAD) тепер посилається на останній комміт у гілці.
Якщо ви внесли зміни до робочого каталогу, які ще не були закоммічені, перемикання гілок буде поганим кроком. Git відмовиться це робити і видасть повідомлення про помилку.

Припустимо, що ви це зробите:

$ git branch devel
$ echo hello > hello
$ git add hello
$ git commit -a -s
$ git checkout devel

ви побачите, що файл h hello не існує у гілці devel.

Також можна об'єднати операції створення нової гілки і її вилучення за допомогою опції -b до операції вилучення (checkout).

Виконання:

$ git checkout -b newbranch startpoint

повністю еквівалентне: 

$ git branch newbranch startpoint
$ git checkout newbranch

-------------------------------------Одержання ранніх версій файлів---------------------------------------

Припустимо, ви хочете побачити попередню версію певного файлу. Ви можете зробити це за допомогою git show, якщо вкажете ім'я шляху на додачу до тегу як ось тут (зверніть увагу на двокрапку): 

$ git show v2.4.1:src/myfile.c

Якщо ви дійсно хочете відновити цю версію, ви можете зробити це за допомогою:

$ git checkout v2.4.1 src/myfile.c

де немає двокрапки.

------------------------------------Лабораторна 8.1. Робота з гілкою розробки----------------------------

Завдання 8.1: Робота з гілкою розробки 

Спочатку ініціалізуйте репозиторій, налаштувавши зі своїм іменем, адресою електронної пошти тощо. Потім додайте кілька файлів до проєкту і закоммітьте їх. 
Створіть нову гілку розробки і перевірте її. 
Змініть один файл і додайте інший, а потім зробіть новий комміт. Перелічіть наявні файли, а також зробіть git ls-files. 
Тепер перевірте оригінальну гілку main. Знову перелічіть наявні файли і виконайте git ls-files. 
Розв’язок 8.1 

1. 

# Ініціалізуйте репозиторій, введіть ім’я, адресу електронної пошти до файлу .config

echo -e "\n\n******** СТВОРЕННЯ РЕПОЗИТОРІЮ ТА КОНФІГУРАЦІЯ\n\n" 

rm -rf git-test ; mkdir git-test ; cd git-test 
git init 
git config user.name "A Smart Guy" 
git config user.email "asmartguy@linux.com" 

echo -e "\n\n********* СТВОРЕННЯ КІЛЬКОХ ФАЙЛІВ, ДОДАВАННЯ ЇХ ДО ПРОЄКТУ ТА КОММІТ\n

# Створіть кілька файлів, додайте їх до проєкту та закоммітьте 
echo file1 > file1 
echo file2 > file2 
git add file1 file2 
git commit . -s -m "Це перший комміт" 

2. 

# Створіть нову гілку розробки

echo -e "\n\n**************** СТВОРЕННЯ НОВОЇ ГІЛКИ devel ***\n\n" 

git branch devel 

# Перевірте нову гілку

echo -e "\n\n*************** ПЕРЕВІРКА ГІЛКИ devel ****\n\n" 

git checkout devel 

3. 

# Змініть файл та додайте ще один

echo another line >> file1 
echo file3 >> file3 

git add file1 file3 

echo -e "\n\n************* ПОРІВНЯННЯ\n\n" 
git diff 

echo -e "\n\n************* НОВИЙ КОММІТ\n\n" 

# А тепер зберіть всі зміни в новий комміт

git commit . -s -m "Це комміт до гілки devel" 

# List files 

echo -e "\n\n перелічіть файли, а потім зробіть git ls-files\n\n" 

ls -l 
git ls-files 

4. 

# Тепер перервіте оригінальну гілку 

echo -e "\n\n************ ПЕРЕЛІЧУВАННЯ ГІЛОК ТА ПЕРЕВІРКА main **\n\n" 

git branch 
git checkout main 

# Перелічьте файли

echo -e "\n\n***************** перелічіть файли, потім зробіть git ls-files\n\n" 

ls -l 
git ls-files 

echo -e "\n\n***************** ПОКАЗАТИ ГІЛКУ\n\n" 

git branch 

Ви можете завантажити скрипти з кроками, наведеними вище:
s_08/lab_branch.sh 
до вашого файлу розв’язків. 
Перегляньте, будь ласка, SOLUTIONS/s 08/lab_branch.sh

--------------------------------