----------------------------------Навчальні цілі---------------------------------------

Опанувавши цей розділ ви зможете:

досліджувати файлову систему та її ієрархію;
пояснювати архітектуру файлової системи;
порівнювати файли та визначати різні типи файлів;
проводити резервне копіювання та стискання даних.

---------------------Вступ до файлових систем------------------------------------------

У Linux (і в усіх UNIX-подібних операційних системах) часто кажуть «усе є файлом» або принаймні все розглядається як файл. Це означає, що незалежно від того, чи ви маєте справу зі звичайними файлами даних і документами, чи з такими пристроями, як звукові карти та принтери, ви взаємодієте з ними через такі самі операції введення / виведення (англ. I/O, Input/Output). Це все спрощує: ви відкриваєте «файл» і виконуєте звичайні операції, такі як читання файлу та запис у ньому (це одна з причин, чому текстові редактори, про які ви дізнаєтесь у наступному розділі, такі важливі).

У багатьох системах (включно з Linux) файлова система структурована як дерево. Дерево зазвичай зображується перевернутим і починається з того, що найчастіше називають кореневим каталогом, який позначає початок ієрархічної файлової системи, а також іноді називають стовбуром або просто позначають слешем «/». Кореневий каталог – це не те саме, що кореневий користувач або суперкористувач. Ієрархічна файлова система також містить інші елементи в шляху (назви каталогів), які відокремлені слешем «/» (наприклад, /usr/bin/emacs), де останній елемент є фактичною назвою файлу.

У цьому розділі ви дізнаєтесь про деякі основні поняття, зокрема про ієрархію файлової системи, а також про розділи диска.

------------------Різновиди файлової системи-------------------------------------------

Linux підтримує деякі типи власних файлових систем, спеціально створених розробниками Linux, наприклад:

ext3
ext4
squashfs
btrfs.
Також Linux пропонує реалізацію файлових систем, які використовуються в інших операційних системах, таких як:

Windows (ntfs, vfat)
SGI (xfs)
IBM (jfs)
MacOS (hfs, hfs+)
Також підтримуються багато застарілих файлових систем, наприклад FAT.

Часто буває так, що на машині використовується більше ніж один тип файлових систем. Це залежить від таких чинників, як розмір файлів, частота їх модифікації, тип апаратного забезпечення, на якому вони розміщені, потрібна швидкість доступу тощо. Найдосконаліші типи файлових систем, які зазвичай використовують, – це різновиди журналювання: ext4, xfs, btrfs і jfs. Вони мають багато найсучасніших функцій і високу продуктивність, і їх дуже важко випадково пошкодити.

---------------------Розділи Linux-----------------------------------------------------

Кожна файлова система в системі Linux займає розділ диска. Розділи допомагають упорядковувати вміст дисків відповідно до типу та використання даних. Наприклад, важливі програми, потрібні для роботи системи, часто зберігаються в окремому розділі (відомому як root, або «/»), окремо від розділів, які містять файли, що належать звичайним користувачам цієї системи (/home). Крім того, тимчасові файли, створені та знищені під час нормальної роботи Linux, можуть розташовуватися у спеціальних розділах. Однією з переваг цього виду ізоляції за типом і варіативністю є те, що коли весь доступний простір на певному розділі вичерпано, система все ще може працювати нормально.

--------------------Точки монтування--------------------------------------------------

Перш ніж почати використовувати файлову систему, її потрібно змонтувати в дереві файлової системи в точці монтування. Це просто каталог (який може бути порожнім, або може не бути порожнім), до якого буде приєднано файлову систему. Іноді, якщо каталогу ще не існує, його треба створити.

ПРИМІТКА. Якщо ви монтуєте файлову систему в непорожньому каталозі, попередній вміст цього каталогу буде закритим і недоступним, доки файлову систему не буде демонтовано. Тому точки монтування – це зазвичай порожні каталоги.

----------------------Монтування і демонтування---------------------------------------

Команду монтування використовують для підключення файлової системи (яка може бути локальною для комп’ютера або в мережі) десь у дереві файлової системи. Основними аргументами є вузол пристрою та точка монтування. Наприклад,

$ sudo mount /dev/sda5 /home

приєднає файлову систему, яка міститься в розділі диска, пов’язаному з вузлом пристрою /dev/sda5, до дерева файлової системи в точці монтування /home. Існують інші способи вказати розділ, крім вузла пристрою, наприклад, за допомогою мітки диска або UUID.

Щоб демонтувати розділ, команда буде такою:

$ sudo umount /home

Зауважте, що правильна команда – umount, а не unmount! Лише користувач root (увійшовши як root або використовуючи sudo) має право виконувати ці команди, якщо систему не налаштовано інакше.

Якщо ви хочете, щоб це було автоматично доступно щоразу, коли запускається система, вам потрібно відповідно відредагувати /etc/fstab (назва – це скорочення від filesystem table). Перегляд цього файлу покаже вам конфігурацію всіх попередньо конфігурованих файлових систем. Man fstab покаже, як цей файл використовувати та як його конфігурувати.

Виконання mount без будь-яких аргументів покаже всі змонтовані файлові системи.

Команда df -Th (disk-free) відобразить інформацію про змонтовані файлові системи, тип файлової системи, а також статистику використання поточного та доступного простору.

-----------------NFS і мережеві файлові системи---------------------------------------

Часто потрібно обмінюватися даними між фізичними системами, які можуть бути або в одному місці, або будь-де, куди можна отримати доступ через інтернет. Мережева файлова система (яку також іноді називають розподіленою) може містити всі свої дані на одній машині або поширювати їх на кількох мережевих вузлах. Багато різних файлових систем можна використовувати локально на окремих машинах; мережеву файлову систему можна розглядати як групу файлових систем нижчого рівня різних типів.

Багато системних адміністраторів монтують каталоги home віддалених користувачів на сервері, щоб надати їм доступ до тих самих файлів і конфігураційних файлів через кілька клієнтських систем. Це дозволяє користувачам входити на різні комп’ютери, але мати доступ до тих самих файлів і ресурсів.

Така найпоширеніша файлова система називається NFS (The Network Filesystem – мережева файлова система). В неї дуже довга історія, вперше вона була розроблена компанією Sun Microsystems. Іншою поширеною реалізацією є CIFS (також називається SAMBA), яка має коріння у Microsoft. Ми зосередимо нашу увагу на NFS.

---------------------NFS на сервері---------------------------------------------------

Розглянемо детально, як використовувати NFS на сервері.

На сервері NFS використовує демони (вбудовані мережеві та сервісні процеси в Linux), а інші системні сервери треба запустити в командному рядку, ввівши

$ sudo systemctl start nfs

ПРИМІТКА. У RHEL / CentOS 8 служба називається nfs-server, а не nfs.

Текстовий файл /etc/exports містить каталоги та дозволи, якими власник бажає поділитися з іншими системами через NFS. Простий запис у цьому файлі може мати такий вигляд:

/projects *.example.com(rw)к

Цей запис дозволяє монтувати каталог /projects за допомогою NFS із дозволами на читання та запис (rw) і надавати спільний доступ іншим власникам у домені example.com. Як ми детально розповімо в наступному розділі, кожен файл у Linux має три можливі дозволи: читання (r), запис (w) і виконання (x).

Після зміни файлу /etc/exports ви можете ввести exportfs -av, щоби повідомити Linux про каталоги, які ви дозволяєте віддалено монтувати за допомогою NFS. Ви також можете перезапустити NFS за допомогою sudo systemctl restart nfs, але це важче, оскільки це зупиняє NFS на короткий час перед повторним запуском. Щоби переконатися, що служба NFS запускається під час кожного завантаження системи, виконайте sudo systemctl enable nfs.

----------------------------NFS клієнта-----------------------------------------------

Якщо потрібно, щоби віддалена файлова система монтувалася автоматично під час завантаження системи на машині клієнта, потрібно змінити /etc/fstab. Наприклад, запис у /etc/fstab клієнта може бути таким:

servername:/projects /mnt/nfs/projects nfs defaults 0 0

Ви також можете монтувати віддалену файлову систему без перезавантаження або як одноразове монтування безпосередньо за допомогою команди mount:

$ sudo mount servername:/projects /mnt/nfs/projects

Пам’ятайте, що якщо /etc/fstab не змінено, це віддалене монтування не існуватиме під час наступного перезапуску системи. Крім того, ви можете використовувати параметр nofail у fstab, якщо сервер NFS не працює під час завантаження.

----------------------------Лабораторна робота 10.1. Дослідження змонтованих файлових систем------------------

Введіть команду:

student:/tmp> cat /etc/fstab

Тепер введіть:

student:/tmp> mount

Порівняйте результати. Які відмінності?

Знайдіть інший спосіб переглянути список змонтованих файлових систем, вивчивши псевдофайлову систему /proc.

Перегляньте запропонований розв’язок лабораторної роботи.

Як правило, mount покаже більше змонтованих файлових систем, ніж показано в /etc/fstab, де перераховані лише ті, які явно запитуються. Однак система монтуватиме додаткові спеціальні файлові системи, потрібні для нормальної роботи, які не перераховані в /etc/fstab.

Ще один спосіб показати змонтовані файлові системи – це ввести

sudent:/tmp> cat /proc/mounts

Це, по суті, спосіб для утиліти отримати інформацію.

---------------------------Огляд домашніх каталогів користувачів----------------------------------

У цьому підрозділі ви навчитеся визначати та розрізняти найважливіші каталоги в Linux. Почнемо з простору звичайних користувачів – каталога home.

Кожен користувач має домашній каталог, який зазвичай розміщується в /home. Каталог /root (slash-root) у сучасних системах Linux є не більше ніж домашнім каталогом користувача root (або суперкористувача, або облікового запису системного адміністратора).

У багатокористувацьких системах інфраструктура каталога /home часто монтується як окрема файлова система на власному розділі або навіть експортується (надається загальний доступ) віддалено в мережу через NFS.

Іноді ви можете групувати користувачів за їхнім відділом або функцією. Потім ви можете створити підкаталоги в каталозі /home для кожної з цих груп. Наприклад, школа може організувати /home приблизно так:

/home/faculty/
/home/staff/
/home/students/

--------------------Каталоги /bin і /sbin----------------------------

У каталозі /bin містяться виконувані двійкові файли, основні команди, які використовують для завантаження системи або в однокористувацькому режимі, а також важливі команди, потрібні всім користувачам системи, наприклад cat, cp, ls, mv, ps, rm.

Подібним чином каталог /sbin призначений для основних бінарних файлів, пов’язаних із адмініструванням системи, наприклад fsck та ip. Щоби переглянути список цих програм, введіть

$ ls /bin /sbin

Команди, які не важливі (теоретично) для завантаження системи або роботи в однокористувацькому режимі, розміщуються в каталогах /usr/bin і /usr/sbin. Раніше це робилося для того, щоб /usr можна було змонтувати як окрему файлову систему на пізнішому етапі запуску системи або навіть через мережу. Однак сьогодні такі дії вважають застарілими. Насправді було виявлено, що багато дистрибутивів не можуть завантажуватися з таким розділенням, оскільки цей спосіб не використовувався або не тестувався протягом тривалого часу.

Таким чином, у деяких найновіших дистрибутивах Linux /usr/bin і /bin фактично просто символічно пов’язані між собою, як і /usr/sbin і /sbin.

--------------------------Файлова система /proc----------------------

Певні файлові системи, як-от змонтована в /proc, називаються псевдофайловими системами, оскільки вони не існують постійно ніде на диску.

Файлова система /proc містить віртуальні файли (файли, які існують лише в пам’яті), які дозволяють переглядати дані ядра, що постійно змінюються. /proc містить файли та каталоги, які імітують структуру ядра та конфігураційну інформацію. Вона містить не справжні файли, а системну інформацію про час виконання, наприклад, системну пам’ять, підключені пристрої, конфігурацію обладнання тощо. Деякі важливі записи в /proc:

/proc/cpuinfo
/proc/interrupts
/proc/meminfo
/proc/mounts
/proc/partitions
/proc/версія

/proc також має підкаталоги, зокрема:

/proc/<Process-ID-#>
/proc/sys

Перший приклад демонструє, що для кожного процесу, запущеного в системі, є каталог, який містить важливу інформацію про нього. Другий приклад демонструє віртуальний каталог, який містить багато інформації про всю систему, зокрема про її апаратне забезпечення та конфігурацію. Файлова система /proc дуже корисна, оскільки інформація, яку вона повідомляє, збирається лише за потреби та ніколи не потребує зберігання на диску.

--------------------------Каталог /dev----------------------------

Каталог /dev містить вузли пристроїв, тип псевдофайлу, який використовується більшістю апаратних і програмних пристроїв, за винятком мережевих пристроїв. Цей каталог:

порожній у розділі диска, якщо він не змонтований;
містить записи, створені системою udev, яка створює та керує вузлами пристроїв у Linux, створюючи їх динамічно, коли пристрої знайдено. Каталог /dev містить такі елементи:
/dev/sda1 (перший розділ на першому жорсткому диску),
/dev/lp1 (другий принтер),
/dev/random (джерело випадкових чисел).

----------------------------Каталог /var-------------------------

Каталог /var містить файли, розмір і вміст яких, як очікується, змінюватимуться під час роботи системи (var означає змінну), наприклад, записи в таких каталогах:

файли системного журналу: /var/log
пакети та файли бази даних: /var/lib
черги друку: /var/spool
тимчасові файли: /var/tmp

Каталог /var можна розмістити у власній файловій системі, щоби можна було пристосуватись до збільшення розмірів файлів і щоби будь-який великий розмір файлу не вплинув фатально на систему. Каталоги мережевих служб, наприклад /var/ftp (служба FTP) і /var/www (вебслужба HTTP), також розміщені у /var.

--------------------------Каталог /etc--------------------------

У каталозі /etc зберігаються конфігураційні файли системи. Він не містить бінарних програм, хоча є деякі виконувані скрипти. Наприклад, /etc/resolv.conf повідомляє системі, куди йти в мережі, щоб отримати відображення імені хоста та IP-адреси (DNS). Такі файли, як passwd, shadow і group для керування обліковими записами користувачів, розміщені в каталозі /etc. Хоча деякі дистрибутиви історично мали власну розгалужену інфраструктуру в /etc (наприклад, Red Hat і SUSE використовували /etc/sysconfig), з появою systemd дистрибутиви стали набагато одноріднішими.

Зауважте, що /etc призначено для загальносистемних конфігураційних файлів, і лише суперкористувач може змінювати файли там. Конфігураційні файли користувача завжди розташовані в його каталозі home.

--------------Каталог /boot-------------------------------------

Каталог /boot містить кілька основних файлів, потрібних для завантаження системи. Для кожного альтернативного ядра, установленого в системі, є чотири файли:

vmlinuz – стиснуте ядро Linux, потрібне для завантаження;
initramfs – початкова файлова система ram, потрібна для завантаження (іноді називається initrd, а не initramfs);
config – конфігураційний файл ядра, який використовується лише для налагодження та обліку;
System.map – таблиця символів ядра, використовується лише для налагодження.
До імені кожного з цих файлів додається версія ядра.

Файли Grand Unified Bootloader (GRUB), такі як /boot/grub/grub.conf або /boot/grub2/grub2.cfg, також розміщені в каталозі /boot.

---------------------Каталоги /lib і /lib64--------------------

/lib містить бібліотеки (загальний код, який спільно використовують програми та який потрібен для їх роботи) для основних програм у /bin та /sbin. Імена файлів цих бібліотек починаються з ld або lib. Наприклад, /lib/libncurses.so.5.9.

Більшість із них – це так звані бібліотеки з динамічним завантаженням (також відомі як shared libraries або Shared Objects (SO)). У деяких дистрибутивах Linux існує каталог /lib64, що містить 64-розрядні бібліотеки, тоді як /lib містить 32-розрядні версії.

В останніх дистрибутивах Linux можна знайти:



Каталоги /lib і /lib64

тобто як і для /bin і /sbin, каталоги просто вказують на каталоги в /usr.

Модулі ядра (код ядра, часто драйвери пристроїв, які можна завантажувати та вивантажувати без перезапуску системи) розміщені в /lib/modules/<kernel-version-number>.

------------------Знімні носії: каталоги /media, /run і /mnt----

Дехто часто користується знімними носіями, такими як USB-накопичувачі, компакт-диски та DVD-диски. Щоби зробити матеріал доступним через звичайну файлову систему, він має бути змонтований у зручному місці. Більшість систем Linux налаштовано таким чином, що будь-який знімний носій автоматично монтується, коли система помічає, що щось підключено.

Хоча раніше це робилося в каталозі /media, сучасні дистрибутиви Linux розміщують ці точки монтування в каталозі /run. Наприклад, USB-накопичувач із міткою myusbdrive для користувача під назвою student буде змонтовано в /run/media/student/myusbdrive.



Каталог /mnt використовувався з перших днів UNIX для тимчасового монтування файлових систем. Це можуть бути файли на знімних носіях, але частіше це можуть бути мережеві файлові системи, які зазвичай не монтуються. Або це можуть бути тимчасові розділи, або так звані петльові файлові системи, які є файлами, які видають себе за розділи.

------------------Додаткові каталоги під /:-------------------------

У кореневому каталозі можна знайти кілька додаткових каталогів:

Назва каталога	Використання
/opt	Додаткові пакети прикладного програмного забезпечення
/sys	Віртуальна псевдофайлова система, яка надає інформацію про систему та апаратне забезпечення. Можна використовувати для зміни параметрів системи та з метою налагодження
/srv	Специфічні для сайта дані, які надає система; використовується рідко
/tmp	Тимчасові файли; у деяких дистрибутивах стерті під час перезавантаження та/або може бути ramdisk у пам’яті
/usr	Багатокористувацькі програми, утиліти та дані

---------------------Дерево каталогів /usr--------------------------

Дерево каталогів /usr містить теоретично несуттєві програми та скрипти (у тому сенсі, що вони не потрібні для початкового завантаження системи) і має принаймні такі підкаталоги:

Назва каталога	Використання
/usr/include	Файли заголовків, які використовують для компіляції програм
/usr/lib	Бібліотеки для програм у /usr/bin та /usr/sbin
/usr/lib64	64-розрядні бібліотеки для 64-розрядних програм у /usr/bin та /usr/sbin
/usr/sbin	Несуттєві бінарні системи, такі як системні демони
/usr/share	Спільні дані, які використовуються програмами, зазвичай незалежні від архітектури
/usr/src	Вихідний код, зазвичай для ядра Linux
/usr/local	Дані та програми, специфічні для локальної машини; підкаталоги містять bin, sbin, lib, share, include тощо.
/usr/bin	Основний каталог виконуваних команд у системі

----------------------Порівняння файлів з diff----------------------

Тепер, коли ви знаєте, що таке файлова система та її структура, навчимося керувати файлами та каталогами.

Утиліту diff часто використовують для порівняння файлів і каталогів. Вона має багато корисних параметрів (man diff), зокрема:

Параметр diff	Використання
-c	Надає список відмінностей, який містить три рядки контексту до та після рядків, що різняться за змістом
-r	Рекурсивне порівняння підкаталогів, а також поточного каталога
-i	Ігнорування регістру літер
-w	Ігнорування відмінностей у пробілах і табуляціях (white space)
-q	Be quiet: повідомляти, лише якщо файли різні, без переліку відмінностей
Щоби порівняти два файли, у командному рядку введіть diff [options] <filename1> <filename2>. diff призначена для використання з текстовими файлами; для бінарних файлів можна застосовувати cmp.

У цьому підрозділі ви дізнаєтесь про додаткові методи порівняння файлів і про те, як застосовувати до файлів патчі.

---------------------Використання diff3 і patch-------------------

Ви можете порівняти три файли одночасно за допомогою diff3, яка використовує один файл як еталонну основу для двох інших. Припустімо, що ви і ваш колега внесли зміни в один файл, працюючи одночасно та незалежно. diff3 може показати відмінності на основі загального файлу, з якого ви обидва почали. Синтаксис diff3 такий:

$ diff3 MY-FILE COMMON-FILE YOUR-FILE

На знімку екрана показано використання diff3.



Використання diff3 

Багато модифікацій вихідного коду та конфігураційних файлів поширюються за допомогою патчів, які, як не дивно, застосовуються разом із програмою patch. Патч-файл містить deltas (зміни), потрібні для оновлення старішої версії файлу до нової. Патч-файли фактично створюються за допомогою запуску diff із правильними параметрами, наприклад:

$ diff -Nur originalfile newfile > patchfile

Поширення лише патчів більш стисле й ефективне, ніж поширення всього файлу. Наприклад, якщо потрібно змінити лише один рядок у файлі, який містить 1000 рядків, патч-файл складатиметься лише з кількох рядків.



Використання патча

Застосувати патч можна двома способами:

$ patch -p1 < patchfile
$ patch originalfile patchfile

Перший більш поширений, оскільки його часто використовують для застосування змін до всього дерева каталогів, а не лише до одного файлу, як у другому прикладі. Щоби зрозуміти використання параметра -p1 та багатьох інших, перегляньте довідкову сторінку за темою patch.

------------------------------Використання утиліти file-------------------

У Linux розширення файлу часто не класифікує його так, як це може бути в інших операційних системах. Не можна вважати, що файл з назвою file.txt – це текстовий файл, а не виконувана програма. У Linux назва файлу зазвичай значить більше для користувача системи, ніж сама система. Більшість програм безпосередньо перевіряють вміст файлу, щоби визначити, який це об’єкт, а не покладаються на розширення. Це дуже відрізняється від того, як Windows обробляє імена файлів, де ім’я файлу, яке закінчується, наприклад, на .exe, позначає виконуваний двійковий файл.

Справжню природу файлу можна з’ясувати за допомогою утиліти file. Для імен файлів, наданих як аргументи, він перевіряє вміст і певні характеристики, щоби визначити, що це за файли – простий текст, спільні бібліотеки, виконувані програми, скрипти чи щось інше.

-------------------------------Лабораторна робота 10.2. Використання diff і patch-----------------

Linux та інші спільноти з відкритим кодом часто використовують утиліту patch для поширення змін і оновлень. Тут ми дамо практичний вступ до використання diff і patch.

Було би непогано почитати довідкові сторінки для diff і patch, щоби дізнатися більше про розширені параметри та методи, які допоможуть ефективніше працювати з patch. Зокрема, форма патчів багато в чому залежить від того, чи можна їх прийняти в поданій формі.

Перейдіть до каталога /tmp.
Скопіюйте текстовий файл до /tmp. Наприклад, скопіюйте /etc/group в /tmp.
dd може копіювати не лише безпосередньо з необроблених дискових пристроїв, але також і зі звичайних файлів. Пам’ятайте, що в Linux майже все розглядається як файл. dd також може виконувати різні перетворення. Наприклад, параметр conv=ucase перетворить усі символи на символи верхнього регістру. Ми використаємо dd, щоби скопіювати текстовий файл у новий файл у /tmp, одночасно переводячи символи у верхній регістр: student:/tmp> dd if=/tmp/group of=/tmp/GROUP conv=ucase.
Згідно з довідковою сторінкою для patch, бажані параметри для підготовки патча з diff – це -Naur під час рекурсивного порівняння двох дерев каталогів. Ми будемо ігнорувати параметр -a, який означає розглядати всі файли як текст, оскільки patch і diff у будь-якому випадку слід використовувати лише для текстових файлів. Оскільки ми лише порівнюємо два файли, нам не потрібно використовувати параметри N або r для diff, але ми можемо використовувати їх у будь-якому випадку, оскільки це не матиме значення. Порівняйте group і GROUP за допомогою diff і підготуйте правильний патч-файл.
Використовуйте patch для виправлення вихідного файлу /tmp/group, щоби його вміст тепер відповідав вмістові зміненого файлу /tmp/GROUP. Можете спочатку спробувати з параметром --dry-run.
Нарешті, щоби довести, що ваш оригінальний файл тепер виправлено відповідно до того, назва якого записана літерами верхнього регістру, використайте diff для обох файлів. Файли мають бути однаковими, і ви не отримаєте жодного результату з diff.
Перегляньте запропонований розв’язок лабораторної роботи.

У цій вправі ви можете використовувати будь-який текстовий файл, але ми візьмемо /etc/group, як і було описано.

1. student:/tmp> cd /tmp

2. student:/tmp> cp /etc/group /tmp

3. student:/tmp> dd if=/tmp/group of=/tmp/GROUP conv=ucase
1+1 records in
1+1 records out
963 bytes (963 B) copied, 0.000456456 s, 2.1 MB/s

4. student:/tmp> diff -Nur group GROUP > patchfile
student:/tmp> cat patchfile

--- group       2015-04-17 11:03:26.710813740 -0500
+++ GROUP       2015-04-17 11:15:14.602813740 -0500
@@ -1,68 +1,68 @@
-root:x:0:
-daemon:x:1:
-bin:x:2:
-sys:x:3:
....
-libvirtd:x:127:student
-vboxsf:x:999:
+ROOT:X:0:
+DAEMON:X:1:
+BIN:X:2:
+SYS:X:3:
.....

5. student:/tmp> patch --dry-run group patchfile
checking file group
student:/tmp> patch  group patchfile
patching file group

6. Зауважте, що ви можете скористатись будь-якою з цих команд:
student:/tmp> patch group < patchfile
student:/tmp> patch < patchfile

7. student:/tmp> diff group GROUP
student:/tmp>

--------------------------------Резервне копіювання даних------------------------------

Існує багато способів резервного копіювання даних або навіть усієї системи. Два основні способи – це просте копіювання за допомогою cp і використання більш надійного rsync.

Обидва можна використовувати для синхронізації цілих дерев каталогів. Однак rsync ефективніша, оскільки вона перевіряє, чи існує вже файл, який копіюється. Якщо файл існує, а розмір чи час модифікації не змінюються, rsync уникне непотрібного копіювання та заощадить час. Крім того, оскільки rsync копіює лише ті частини файлів, які фактично змінилися, це буде швидкий процес.



Текст зображення:

Резервне копіювання

cp може лише копіювати файли у визначені місця чи з них на локальній машині (якщо ви не копіюєте у або з файлової системи, змонтованої за допомогою NFS), але rsync також можна використовувати для копіювання файлів з однієї машини на іншу. Розташування вказуються у формі target:path, де target може бути у формі someone@host. Компонент someone@ необов’язковий і використовується, якщо віддалений користувач відрізняється від локального.

rsync дуже ефективна під час рекурсивного копіювання одного дерева каталогів до іншого, тому що лише відмінності передаються через мережу. Часто дерево каталогів призначення синхронізується із джерелом за допомогою параметра -r, щоби рекурсивно пройтися деревом каталогів, копіюючи всі файли та каталоги під тим, що зазначено як джерело.

--------------------------Використання rsync------------------------------------------

rsync – дуже потужна утиліта. Наприклад, корисним способом створення резервної копії каталога проєкту може бути застосування такої команди:

$ rsync -r project-X archive-machine:archives/project-X

Зверніть увагу, що rsync може бути дуже і руйнівною! Випадкове неправильне використання – ненавмисне копіювання змін туди, де вони не потрібні – може завдати великої шкоди даним і програмам. Стежте за правильними параметрами та шляхами. Рекомендуємо спочатку перевірити свою команду rsync за допомогою параметра -dry-run, щоби переконатися, що вона забезпечує бажані результати.



Щоби використати rsync у командному рядку, введіть rsync sourcefile destinationfile, де будь-який файл може бути на локальній машині або на машині в мережі; вміст sourcefile буде скопійовано до destinationfile.

Ще один приклад хорошої комбінації варіантів:

$ rsync --progress -avrxH --delete sourcedir destdir

---------------------------Стискання даних-----------------------------------------------

Файлові дані часто стискаються, щоби заощадити місце на диску та зменшити час передачі файлів через мережі.

У Linux є кілька методів для виконання стискання:

Команда	Використання
gzip	Найбільш часто використовувана утиліта стискання Linux
bzip2	Створює файли значно менші за ті, які створює gzip
xz	Найбільш ефективна утиліта стискання в Linux
zip	Часто потрібна для перевірки та розпакування архівів з інших операційних систем
Ці методи розрізняються за ефективністю стискання (скільки збережено місця) і за часом, потрібним для стискання. Зазвичай більш ефективні методи потребують більше часу. Час розпакування не сильно відрізняється в різних методах.

Утиліту tar часто використовують для групування файлів в архіві, а потім стискання всього архіву одночасно.

-----------------------Стискання даних за допомогою gzip--------------------------

Утиліту стискання gzip у Linux застосовують найчастіше. Вона ефективно і швидко працює. У таблиці наведено кілька прикладів її використання:

Команда	Використання
gzip *	Стискає всі файли в поточному каталозі; кожен файл стискається та перейменовується з розширенням .gz.
gzip -r projectX	Стискає всі файли в каталозі projectX разом з усіма файлами в усіх каталогах у projectX.
gunzip foo	Розпаковує foo, знайдений у файлі foo.gz. Насправді, команда gunzip фактично така сама, як gzip -d

-------------------Стискання даних за допомогою bzip2------------------------------

bzip2 має синтаксис, подібний до gzip, але використовує інший алгоритм стискання та створює файли значно меншого розміру, проте протягом значно більшого часу. Тому її краще застосовувати для стискання великих файлів.

Приклади загального використання також подібні до gzip:

Команда	Використання
bzip2 *	Стискає всі файли в поточному каталозі та замінює кожен файл файлом із перейменованим розширенням .bz2.
bunzip2 *.bz2	Розпаковує всі файли з розширенням .bz2 у поточному каталозі. По суті, bunzip2 – це те саме, що й bzip2 -d.
ПРИМІТКА. bzip2 нещодавно стала застарілою через відсутність обслуговування та чудові коефіцієнти стискання xz, яка активно підтримується.

---------------------------Стискання даних за допомогою xz----------------------

xz – це утиліта стискання з найбільшим обсягом в Linux. Її використовують для зберігання архівів ядра Linux. xz забезпечує ще вищий рівень стискання, проте ще нижчу швидкість стискання.

Деякі приклади використання:

Команда	Використання
xz *	Стискає всі файли в поточному каталозі та замінює кожен файл файлом із розширенням .xz
xz foo	Стискає foo у foo.xz, використовуючи стандартний рівень стиснення (-6), і видаляє foo, якщо стиснення вдається
xz -dk bar.xz	Розпаковує bar.xz у bar і не видаляє bar.xz, навіть якщо розпакування виконано успішно
xz -dcf a.txt b.txt.xz > abcd.txt	Розпаковує разом стиснені та нестиснені файли у стандартний вихід за допомогою однієї команди
xz -d *.xz	Розпаковує файли, стиснені за допомогою xz
Стиснуті файли зберігаються із розширенням .xz.

-----------------------------Робота з файлами за допомогою zip---------------------

Програму zip не часто використовують для стискання файлів у Linux, але вона часто потрібна для перевірки та розпакування архівів з інших операційних систем. zip використовують у Linux лише тоді, коли ви отримуєте заархівований файл від користувача Windows. Це застаріла програма.

Команда	Використання
zip backup *	Стискає всі файли в поточному каталозі та розміщує їх у backup.zip
zip -r backup.zip ~	Архівує ваш каталог входу (~) і всі файли та каталоги в ньому в backup.zip
unzip backup.zip	Видобуває всі файли в backup.zip і розміщує їх у поточному каталозі

-------------------------------Архівування та стискання даних за допомогою tar---------

tar – це абревіатура від tape archive. Раніше його використовували для архівування файлів на магнітну стрічку. Він дозволяє створювати або видобувати файли з архівного файлу, який часто називають tarball. Водночас ви можете додатково стиснути під час створення архіву та розпакувати під час видобування його вмісту.

Ось кілька прикладів використання tar:

Команда	Використання
tar xvf mydir.tar	Видобуває всі файли з mydir.tar у каталог mydir
tar zcvf mydir.tar.gz mydir	Створює архів і стискає його за допомогою gzip
tar jcvf mydir.tar.bz2 mydir	Створює архів і стискає його за допомогою bz2
tar Jcvf mydir.tar.xz mydir	Створює архів і стискає його за допомогою xz
tar xvf mydir.tar.gz	Видобуває всі файли з mydir.tar.gz у каталог mydir
ПРИМІТКА. Вам не потрібно повідомляти tar, що це у форматі gzip.
Ви можете розділити етапи архівування та стискання, наприклад:

$ tar cvf mydir.tar mydir ; gzip mydir.tar
$ gunzip mydir.tar.gz ; tar xvf mydir.tar

Однак майте на увазі, що це повільніший процес, а також марнування простору, тому що створюється непотрібний проміжний файл .tar.

----------------------------Порівняння часу стискання і розмірів------------------------

Щоби продемонструвати відносну ефективність gzip, bzip2 і xz, на наступному знімку екрана показано результати стискання дерева каталогів текстового файлу (каталог include з джерела ядра) за допомогою трьох методів.



Порівняння часу стискання і розмірів

Видно, що зі збільшенням коефіцієнтів стискання збільшується і час CPU (тобто для створення менших архівів потрібно більше часу).

-----------------------Копіювання з диска на диск (dd)--------------------------------

Програма dd корисна для створення копій необробленого дискового простору. Наприклад, щоби створити резервну копію головного завантажувального запису (Master Boot Record (MBR)) (першого 512-байтного сектора на диску, який містить таблицю з описом розділів на цьому диску), ви можете ввести:

dd if=/dev/sda of=sda.mbr bs=512 count=1

УВАГА!

При введенні

dd if=/dev/sda of=/dev/sdb

щоб зробити копію одного диска на інший, буде видалено все, що раніше існувало на другому диску.

На другому дисковому пристрої створюється точна копія першого дискового пристрою.

Не експериментуйте з цією командою, як написано вище, оскільки вона може стерти жорсткий диск!

Навколо назви dd ще й досі точаться суперечки. Варіант data definition (визначення даних) – це найпопулярніший варіант, яка сягає корінням у ранню історію IBM. Та часто ще й жартують, що це руйнівник дисків (disk destroyer) або ж видалення даних (delete data).

---------------------------Лабораторна робота 10.3. Архівування (резервне копіювання) каталога home---------------------

Архівування (або резервне копіювання) файлів час від часу обов’язкове. Ви можете ввести якусь команду і ненавмисно стерти файли, які вам потрібні і які ви не збиралися змінювати.

Крім того, хоча ваше обладнання можна вважати надійним, усі пристрої так чи інакше виходять з ладу (навіть якщо це просто несподіваний збій живлення). І часто це відбувається в найневідповідніший час. Періодичне резервне копіювання файлів – хороша звичка.

Звісно, важливо робити резервні копії на зовнішні системи через мережу або на зовнішню пам’ять, наприклад, зовнішній диск чи USB-накопичувач. Зараз ми створимо резервну копію архіву в тій самій системі. Це дуже корисно, проте не допоможе, якщо диск вийде з ладу або ваш комп’ютер викрадуть, або на будівлю впаде астероїд чи в ній станеться пожежа.

Спочатку за допомогою tar створіть резервні копії всіх файлів і підкаталогів у вашому каталозі home. Помістіть отриманий архівний файл у каталог /tmp, назвіть його backup.tar.

Далі виконайте те саме завдання зі стисканням gzip, використовуючи параметр -z для tar, створюючи /tmp/backup.tar.gz.

Порівняйте розмір двох файлів (за допомогою ls -l).

Для отримання додаткового досвіду створіть резервні копії за допомогою bzip2 із параметром -j і за допомогою xz із параметром -J.

Перегляньте запропонований розв’язок лабораторної роботи.

Щоб створити tar-архів вашого домашнього каталога, ви можете ввести:

student:/tmp> tar -cvf /tmp/backup.tar ~

або, що те саме,

student:/tmp> tar -cvf /tmp/backup.tar /home/student

Зверніть увагу, що ви могли пропустити «-» в параметрах без змін. Далі ми не будемо турбуватися про використання параметра -v. Щоб створити архіви за допомогою всіх трьох утиліт стискання, запустіть:

student:/tmp> tar zcf /tmp/backup.tar.gz ~
student:/tmp> tar jcf /tmp/backup.tar.bz2 ~
student:/tmp> tar Jcf /tmp/backup.tar.xz ~

Порівняння розмірів (спочатку з параметром -h для ls, щоби зробити їх читабельними для людського ока):

student@ubuntu:~student:/tmp> ls -lh /tmp/backup*

-rw-rw-r-- 1 student student 8.3M Apr 17 10:14 /tmp/backup2.tar.gz
-rw-rw-r-- 1 student student  12M Apr 17 10:13 /tmp/backup.tar
-rw-rw-r-- 1 student student 8.4M Apr 17 10:15 /tmp/backup.tar.bz2
-rw-rw-r-- 1 student student 8.3M Apr 17 10:14 /tmp/backup.tar.gz
-rw-rw-r-- 1 student student 8.2M Apr 17 10:15 /tmp/backup.tar.xz

а потім без нього:

student@ubuntu:~student:/tmp> ls -l /tmp/backup*

-rw-rw-r-- 1 student student  8686942 Apr 17 10:14 /tmp/backup2.tar.gz
-rw-rw-r-- 1 student student 12226560 Apr 17 10:13 /tmp/backup.tar
-rw-rw-r-- 1 student student  8720491 Apr 17 10:15 /tmp/backup.tar.bz2
-rw-rw-r-- 1 student student  8686929 Apr 17 10:14 /tmp/backup.tar.gz
-rw-rw-r-- 1 student student  8551064 Apr 17 10:15 /tmp/backup.tar.xz

Зауважте, що в цьому випадку немає великої різниці в різних методах архівування, але цей конкретний каталог був поганим вибором, оскільки він уже містив багато стиснених файлів. Ось дещо кращий приклад із більшою кількістю текстових файлів:

student:/tmp> tar cf  /tmp/doc.tar     /usr/share/doc
student:/tmp> tar zcf /tmp/doc.tar.gz  /usr/share/doc
student:/tmp> tar jcf /tmp/doc.tar.bz2 /usr/share/doc
student:/tmp> tar Jcf /tmp/doc.tar.xz  /usr/share/doc
student:/tmp> ls -lh /tmp/doc.tar*

-rw-rw-r-- 1 student student 85M Apr 17 10:34 /tmp/doc.tar
-rw-rw-r-- 1 student student 31M Apr 17 10:35 /tmp/doc.tar.bz2
-rw-rw-r-- 1 student student 34M Apr 17 10:34 /tmp/doc.tar.gz
-rw-rw-r-- 1 student student 28M Apr 17 10:36 /tmp/doc.tar.xz

який показує, що xz впоралася найкраще, за нею bz2, а потім gz. Однак ви, можливо, помітили зворотний зв’язок між зменшенням розміру стискання та часом, протягом якого він тривав.

-------------------------Короткий зміст розділу---------------------------------------

Ви завершили розділ 10. Підсумуймо основні розглянуті поняття:

Дерево файлової системи починається з того, що часто називають кореневим каталогом (або trunk, або /).
Стандарт ієрархії файлової системи (Filesystem Hierarchy Standard (FHS)) надає розробникам і системним адміністраторам Linux стандартну структуру каталогів для файлової системи.
Розділи допомагають розділяти файли відповідно до використання, власника й типу.
Файлові системи можна монтувати будь-де на головному дереві файлової системи в точці монтування. Автоматичне монтування файлової системи можна налаштувати шляхом редагування /etc/fstab.
NFS (Network File System) – це спосіб обміну файлами та даними через мережеві системи.
Файлові системи, такі як /proc, називаються псевдофайловими системами, оскільки вони існують лише в пам’яті.
/root (slash-root) – домашній каталог для користувача root.
/var можна помістити у власну файлову систему, щоб можна було стримувати зростання і не вплинути на систему фатально.
/boot містить основні файли, потрібні для завантаження системи.
patch – дуже корисний інструмент у Linux. Багато модифікацій вихідного коду та конфігураційних файлів поширюються разом із патч-файлами, оскільки вони містять deltas, або зміни, для переходу від старої версії файлу до нової версії файлу.
У Linux розширення файлів не обов’язково вказує на те, що файл має конкретно це розширення.
cp використовують для копіювання файлів на локальній машині, тоді як rsync можна використовувати для копіювання файлів з однієї машини на іншу, а також для синхронізації вмісту.
gzip, bzip2, xz і zip використовують для стискання файлів.
tar дозволяє створювати або видобувати файли з архіву, який часто називають tarball. Ви можете додатково стиснути під час створення архіву та розпакувати під час видобування його вмісту.
dd можна використовувати для ефективного створення великих точних копій навіть цілих розділів диска.