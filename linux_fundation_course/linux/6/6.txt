--------------------------Навчальні цілі-----------------------------------------

До кінця цього розділу ви зможете:

Використовувати командний рядок для виконання операцій у Linux.
Виконувати пошук файлів.
Створювати файли та керувати ними.
Інсталювати й оновлювати програмне забезпечення.

----------------------Знаймоство з командним рядком------------------------------

Системні адміністратори Linux витрачають значну кількість часу на командний рядок. Вони часто автоматизують і вносять виправлення в цьому текстовому середовищі. Є навіть така приказка: «Графічні інтерфейси користувача полегшують легкі завдання, а інтерфейси командного рядка роблять складні завдання можливими». Linux значною мірою покладається на велику кількість інструментів командного рядка. Інтерфейс командного рядка надає такі переваги:

Не виникає додаткового навантаження на графічний інтерфейс користувача.
У командному рядку можна виконати майже будь-яке завдання.
Ви можете запровадити сценарії для часто використовуваних завдань або до завдань, про які легко забути, і серій процедур.
Ви можете ввійти на віддалені машини будь-де в інтернеті.
Ви можете запустити графічні програми безпосередньо з командного рядка, а не шукати їх у меню.
Графічні інструменти можуть різнитися в різних дистрибутивах Linux, проте інтерфейс командного рядка скрізь однаковий.

----------------------Використання текстового термінала на графічному робочому столі---------------------------

Програма-емулятор термінала емулює (імітує) автономний термінал у вікні на робочому столі. Під цим ми маємо на увазі, що він поводиться так, ніби ви входите в машину за допомогою суто текстового термінала без запущеного графічного інтерфейсу. Більшість програм-емуляторів термінала підтримують кілька сеансів термінала, відкриваючи додаткові вкладки або вікна.

За замовчуванням у середовищі робочого столу GNOME програма gnome-terminal використовується для емуляції текстового термінала у вікні. Серед інших доступних термінальних програм:

xterm,
konsole (за замовчуванням у KDE),
terminator.
Натисніть на зображення, щоби переглянути його збільшену версію.

----------------------------Запуск термінала Windows-----------------------------------------------------------

Щоби відкрити термінал у будь-якій системі за допомогою останнього робочого столу GNOME, натисніть Applications > System Tools > Terminal або Applications > Utilities > Terminal. Якщо у вас немає меню Applications, вам доведеться інсталювати відповідний пакет gnome-shell-extension і включити gnome-tweaks.

У будь-якому, крім деяких останніх дистрибутивів на основі GNOME, ви завжди можете відкрити термінал, клацнувши правою кнопкою миші будь-де на робочому столі та вибравши Open in Terminal. Якщо це не спрацює, вам потрібно буде знову інсталювати й активувати відповідний пакет gnome-shell-extension.

Ви також можете натиснути Alt+F2 і ввести gnome-terminal або konsole, залежно від того, що підходить. Оскільки в дистрибутивах була історія відкриття термінала командного рядка, а місце в меню може бути різним залежно від графічного інтерфейсу робочого столу, доцільно з’ясувати, як «закріпити» піктограму термінала на панелі, що може означати додавання його до групи Favorites в системах GNOME.

-----------------------------------------Деякі основні утиліти-------------------------------------------------

Є деякі основні утиліти командного рядка, які використовуються постійно, і щоб продовжити роботу, потрібно використати деякі з них у простій формі, перш ніж ми обговоримо їх більш детально. Короткий список такий:

cat: для виведення файлу (або об’єднання файлів);
head: для показу перших кількох рядків файлу;
tail: для показу кількох останніх рядків файлу;
man: для перегляду документації.
На скріншоті показано елементарне використання цих програм. Зверніть увагу на використання вертикальної риски «|» – символу каналу: для однієї програми це будуть вхідні дані, а для іншої – вихідні. Здебільшого ми будемо використовувати ці утиліти лише на знімках екрана, які відображають різні дії, перш ніж детально їх обговорювати. Спершу ви будете бачити ці утиліти лише на знімках екрана як демонстрацію різних дій, а вже потім обговоримо їх більш детально. 

---------------------------------------Командний рядок----------------------------------------------------------

ільшість рядків вводу в оболонці командного рядка мають три основні елементи:

команда;
параметри;
аргументи.
Команда – це назва програми, яку ви виконуєте. За нею може слідувати один або кілька параметрів (або перемикачів), які змінюють те, що може робити команда. Параметри зазвичай починаються з одного-двох дефісів, наприклад: -p або -print; це робиться для того, щоби не плутати їх з аргументами, які представляють те, над чим працює команда.

Однак багато команд мають або параметри, або аргументи, або не мають ні того, ні іншого. Крім того, інші елементи (наприклад, установлення змінних середовища) можуть з’являтися в командному рядку під час запуску завдання.

-------------------------------------sudo------------------------------------------------------------------------

Усі створені демонстрації мають користувача, налаштованого з можливостями sudo, щоб надати користувачеві привілеї адміністратора, коли це потрібно. sudo дозволяє користувачам запускати програми, використовуючи привілеї безпеки іншого користувача, як правило, суперкористувача (root).

У ваших системах може знадобитися установка та ввімкнення sudo для коректної роботи. Щоб зробити це, потрібно виконати кілька кроків, які ми не пояснюватимемо зараз, але ви дізнаєтеся про них пізніше в цьому курсі. Під час роботи в Ubuntu та деяких інших останніх дистрибутивах sudo завжди вже налаштовано під час інсталяції. В інших дистрибутивах Linux вам радше за все потрібно буде налаштувати sudo, щоби вона працювала належним чином після початкової інсталяції.

Далі ви дізнаєтеся, як налаштувати та запустити sudo у вашій системі.

------------------------------Кроки для налаштування та запуску sudo---------------------------------------------

Якщо у вашій системі ще не налаштовано та не запущено sudo, потрібно виконати такі дії:

1. Потрібно буде внести зміни як адміністратор, або суперкористувач (root). І хоча sudo стане найкращим способом для цього, ми його ще не налаштували, тому замість нього використаємо su (про яку ми детально розповімо пізніше). У командному рядку введіть su та натисніть Enter.  Після цього вам буде запропоновано ввести пароль адміністратора: введіть його та натисніть Enter. Ви помітите, що нічого не друкується. Це робиться для того, щоб інші не бачили пароль на екрані. Ви маєте отримати інший підказки, які часто закінчується на «#».  Наприклад:

$ su Password:
#

2. Тепер потрібно створити конфігураційний файл, щоби ваш обліковий запис міг використовувати sudo. Як правило, цей файл створюється в каталозі /etc/sudoers.d/ з іменем файлу, що збігається з вашим іменем користувача. Наприклад, у прикладі, поданому нижче, ваше ім’я користувача student. Після виконання першого кроку ви створите конфігураційний файл для student, виконавши такі дії:

# echo "student ALL=(ALL) ALL" > /etc/sudoers.d/student

3. Деякі дистрибутиви Linux будуть скаржитися, якщо ви також не змінюєте дозволи на файл, виконуючи:

# chmod 440 /etc/sudoers.d/student

Це має бути все. До кінця курсу, якщо ви використовуєте sudo, ви повинні бути правильно налаштовані. Під час використання sudo вам за замовчуванням буде запропоновано ввести пароль (ваш пароль користувача), принаймні коли ви робите це вперше протягом певного інтервалу часу. Можна (хоча й дуже небезпечно) налаштувати sudo так, щоби пароль не вимагався, або змінити часовий проміжок, у якому пароль не потрібно повторювати для кожної команди sudo.

------------------------Переключення між графічним інтерфейсом користувача та командним рядком-----------------------

Настроюваний характер Linux дозволяє відключити графічний інтерфейс (тимчасово чи назавжди) або запустити його після того, як систему запущено.

Більшість дистрибутивів Linux надають під час інсталяції (або мають більше ніж одну версію інсталяційного носія) можливість вибрати між робочим столом (із графічним робочим столом) і сервером (зазвичай без нього).

Робочі сервери Linux зазвичай інсталюються без графічного інтерфейсу користувача, і навіть якщо він інстальований, зазвичай його не запускають під час запуску системи. Видалення графічного інтерфейсу з робочого сервера може бути дуже корисним для ощадливої системи, яку легше підтримувати у безпеці.

-------------------------------------Віртуальні термінали------------------------------------------------------------

Віртуальні термінали (Virtual Terminals, VT) – це консольні сеанси, які використовують весь дисплей і клавіатуру за межами графічного середовища. Такі термінали вважаються «віртуальними», оскільки, хоча активних терміналів може бути кілька, одночасно залишається видимим лише один термінал. VT – це не зовсім те саме, що вікно термінала командного рядка; ви можете мати багато таких, видимих одночасно на графічному робочому столі.

Один віртуальний термінал (зазвичай номер один або сім) зарезервовано для графічного середовища, а текстові входи ввімкнено на невикористаних VT. Ubuntu використовує VT 7, але CentOS/RHEL і openSUSE використовують VT 1 для графічного дисплея.

Використання VT може бути корисним, коли у вас виникають проблеми з графічним робочим столом. У цій ситуації ви можете перейти до одного з текстових VT і усунути несправність.

Щоби переключатися між VT, натисніть CTRL+ALT+функціональну клавішу для VT. Наприклад, натисніть CTRL+ALT+F6 для VT 6. Та якщо ви вже у VT і хочете переключитися на інший VT, достатньо натиснути комбінацію клавіш ALT+F6.

-----------------------------------Вимкнення графічного робочого столу-----------------------------------------------

Дистрибутиви Linux можуть запускати та зупиняти графічний робочий стіл різними способами. Точний метод різниться залежно від дистрибутива та версій дистрибутива. Для нових дистрибутивів на основі systemd менеджер дисплея запускається як служба; ви можете зупинити робочий стіл GUI за допомогою утиліти systemctl, а більшість дистрибутивів також працюватимуть за допомогою команди telinit:

$ sudo systemctl stop gdm (або sudo telinit 3)

і перезапустити (після входу в консоль) за допомогою:

$ sudo systemctl start gdm (або sudo telinit 5)

У версіях Ubuntu до 18.04 LTS замініть lightdm на gdm.

------------------------------------Лабораторна робота 7.1. Припинення роботи графічного інтерфейсу користувача------------

З графічного термінала (gnome-terminal, konsole тощо) закрийте поточний графічний стіл.

Спосіб залежатиме від вашого дистрибутива та програми привітання (gdm, lightdm, kdm), а також від того, чи є у вас система systemd, SysVinit або Upstart.

Перезапустіть GUI з консолі.

Перегляньте запропонований розв’язок лабораторної роботи.

-------------------------------------Лабораторна робота 7.1. Розв’язок-----------------------------------------------------

Спосіб виведення GUI з ладу:

student:/tmp> sudo systemctl stop gdm
student:/tmp> sudo systemctl stop lightdm
student:/tmp> sudo telinit 3

Способи відновлення графічного інтерфейсу користувача:

student:/tmp> sudo systemctl start gdm
student:/tmp> sudo systemctl start lightdm
student:/tmp> sudo telinit 5

------------------------------------Основні операції------------------------------------------------------------------------

У цьому розділі ми поговоримо про те, як виконувати основні операції з командного рядка: увійти до системи та вийти з неї, перезапустити систему чи завершити роботу системи, знайти програми, отримати доступ до каталогів, визначити абсолютні та відносні шляхи та дослідити файлову систему.

---------------------------------Вхід і вихід-------------------------------------------------------------------------------

Доступний текстовий термінал запропонує ввести ім’я користувача (з рядком login:) і пароль. Під час введення пароля на терміналі нічого не відображається (навіть символ «*» для вказування на те, що ви щось ввели), щоб інші не бачили ваш пароль. Після входу до системи ви можете виконувати основні операції.

Коли сеанс почався (чи через текстовий термінал, чи через програму графічного термінала), ви також можете підключитися та увійти у віддалені системи за допомогою Secure SHell (SSH). Наприклад, якщо ввести ssh student@remote-server.com, SSH безпечно з’єднається з віддаленою машиною (remote-server.com) і надасть student вікно термінала командного рядка, з використанням пароля (як при звичайному вході) або криптографічного ключа для входу без введення пароля для підтвердження особи.

------------------------------------------------Перезавантаження та завершення роботи---------------------------------------

Найкращим методом завершити роботу або перезавантажити систему є використання команди shutdown. Вона надсилає попереджувальне повідомлення, а потім запобігає входу інших користувачів. Процес init керуватиме завершенням роботи або перезавантаженням системи. Важливо завжди правильно вимикати. Недотримання цієї вимоги може призвести до пошкодження системи та / або втрати даних.

Команди halt і poweroff видають shutdown -h, щоби зупинити систему; reboot викликає shutdown -r і змушує машину перезавантажуватись, а не просто завершувати роботу. Як для перезавантаження, так і для завершення роботи з командного рядка потрібен доступ суперкористувача (root).

Під час адміністрування багатокористувацької системи у вас є можливість сповістити всіх користувачів перед завершенням роботи, наприклад:

$ sudo shutdown -h 10:00 "Shutting down for scheduled maintenance."

ПРИМІТКА. В останніх дистрибутивах Linux на базі Wayland широкомовні повідомлення не відображаються під час сеансів емуляції термінала, запущених на робочому столі; вони відображаються лише на дисплеях консолі VT.

-----------------------------------------------Розташування програм----------------------------------------------

Залежно від особливостей політики вашого конкретного дистрибутива програми та пакети програмного забезпечення можна інсталювати в різні каталоги. Загалом, виконувані програми та сценарії мають розташовуватися в каталогах /bin, /usr/bin, /sbin, /usr/sbin або десь у /opt. Вони також можуть з’являтися в /usr/local/bin і /usr/local/sbin або в каталозі в просторі облікового запису користувача, наприклад, /home/student/bin.

Один зі способів знайти програми – скористатися утилітою which. Наприклад, щоб дізнатися, де саме у файловій системі розміщена програма diff:

$ which diff
/usr/bin/diff

Якщо which не знаходить програму, то whereis – це хороша альтернатива, оскільки вона шукає пакети в ширшому діапазоні системних каталогів:

$ whereis diff
diff: /usr/bin/diff 
/usr/share/man/man1/diff.1.gz 
/usr/share/man/man1p/diff.1p.gz

а також визначає джерело і файли man, що входять до складу програми.

-----------------------------------------Доступ до каталогів------------------------------------------------------

Коли ви вперше входите до системи або відкриваєте термінал, каталогом за замовчуванням буде каталог Home. Ви можете надрукувати точний шлях до цього, ввівши echo $HOME. Багато дистрибутивів Linux фактично відкривають нові графічні термінали в $HOME/Desktop. Для навігації каталогом корисні такі команди:

Команда	Результат
pwd	Відображає поточний робочий каталог
cd ~ або cd	Перехід до домашнього каталога (ім’я ярлика ~ (tilde))
cd ..	Перехід до батьківського каталога (..)
cd -	Перехід до попереднього каталога (- (minus))
puhd -  hystory
popd - preivious catalog

---------------------------------------Розуміння абсолютних і відносних шляхів------------------------------------

Є два способи визначення шляхів:

Абсолютний шлях. Абсолютне ім’я шляху починається з кореневого каталога і йде за деревом, гілка за гілкою, доки не досягне потрібного каталога або файлу. Абсолютні шляхи завжди починаються з символу «/».
Відносний шлях. Відносний шлях починається з поточного робочого каталога. Відносні шляхи ніколи не починаються з символу «/».
Кілька слешів (/) між каталогами та файлами дозволені, але система ігнорує всі слеші між елементами в імені шляху, крім одного. ////usr//bin дійсний, але система бачить його як /usr/bin.

У більшості випадків найзручніше використовувати відносні шляхи, які потребують введення меншої кількості символів. Зазвичай ви користуєтеся ярликами: . (поточний каталог), .. (батьківський каталог) і ~ (ваш каталог Home).

Припустімо, що ви зараз працюєте у домашньому каталозі та хочете перейти до каталога /usr/bin. Є два способи перейти в цей каталог з каталога Home:

Абсолютний шлях:
$ cd /usr/bin
Відносний шлях:
$ cd ../../usr/bin
У цьому випадку метод абсолютного шляху потребує менше введення.

--------------------------------------------Вивчення файлової системи---------------------------------------------

Перехід вверх і вниз деревом файлової системи може втомлювати. Команда tree – це хороший спосіб отримати вид дерева файлової системи з висоти пташиного польоту. Використовуйте tree -d, щоби переглянути лише каталоги та заблокувати перелік файлів.

Ці команди можуть допомогти у дослідженні файлової системи:

Команда	Використання
cd /	Змінює поточний каталог на кореневий (/) каталог (або вказаний вами шлях)
Ls	Список вмісту поточного робочого каталога
ls -a	Список усіх файлів, включно з прихованими файлами та каталогами (ті, чиї назви починаються з «.»)
Tree	Подає файлову систему у вигляді дерева

----------------------------------------------Жорсткі посилання---------------------------------------------------

Утиліту ln використовують для створення жорстких посилань і (з параметром -s) м’яких посилань, також відомих як symbolic links або symlinks. Ці два типи посилань дуже корисні в операційних системах на основі UNIX.

Припустимо, що file1 уже існує. Жорстке посилання під назвою file2 створюється за допомогою такої команди:

$ ln file1 file2

Зауважте, що зараз існує два файли. Однак уважне вивчення списку файлів показує, що це не зовсім так.

$ ls -li file1 file2

Параметр -i для ls друкує в першому стовпці номер inode, який є унікальною величиною для кожного файлового об’єкта. Це поле однакове для обох цих файлів. Що відбувається насправді? Це лише один файл, але він має більше ніж одне ім’я, пов’язане з ним, на що вказує 2, яке з’являється у виводі ls. Тобто до виконання команди вже був інший об’єкт, пов’язаний з file1.

Жорсткі посилання дуже корисні й економлять простір, але ви маєте обережно їх використовувати. По-перше, якщо ви видалите file1 або file2 у прикладі, об’єкт inode (і решта імені файлу) залишиться, що може бути небажано, оскільки це може призвести до незначних помилок пізніше, якщо ви повторно створите файл із такою назвою.

Якщо ви відредагуєте один із файлів, то те, що станеться, залежить від вашого редактора: більшість редакторів, включно з vi та gedit, збережуть посилання за замовчуванням, але можливо, що зміна одного з імен може порушити посилання та призвести до створення двох об’єктів.

------------------------------------------М’які (символічні) посилання----------------------------------------------

М’які (або символічні) посилання створюються за допомогою параметра -s, наприклад:

$ ln -s file1 file3
$ ls -li file1 file3

Зауважте, що file3 більше не схожий на звичайний файл, він чітко вказує на file1 і має інший номер inode.

Символічні посилання не займають додаткового місця у файловій системі (якщо їх імена не дуже довгі). Вони надзвичайно зручні, оскільки їх можна легко модифікувати, щоби вказувати на різні місця. Простий спосіб створити ярлик із вашого каталога Home на довгі шляхи – це створити символічне посилання.

М’які посилання, на відміну від жорстких, можуть вказувати на об’єкти навіть у різних файлових системах, розділах та / або дисках та інших носіях, які можуть бути або не бути доступними на цей момент або навіть існувати чи не існувати. У випадку, коли посилання не вказує на поточний доступний або наявний об’єкт, ви отримаєте зависле посилання.

--------------------------------------------Навігація в історії каталога----------------------------------------------

Команда cd запам’ятовує, де ви були востаннє, і дозволяє повернутися туди за допомогою команди cd -.  Щоб запам’ятати не лише останній відвіданий каталог, використовуйте pushd, щоби змінити каталог, а не cd; це виштовхує ваш початковий каталог до списку. Команда popd поверне вас до цих каталогів у зворотному порядку (останній каталог буде першим, отриманим за допомогою popd). Список каталогів відображається за допомогою команди dirs.

----------------------------------------------Лабораторна робота 7.2. Розташування програм----------------------------

Дізнайтеся розташування мережевої утиліти ip.

Перегляньте запропонований розв’язок лабораторної роботи.


Лабораторна робота 7.2. Розв’язок

student:/tmp> which ip
/usr/sbin/ip

student:/tmp> whereis ip
ip: /usr/sbin/ip /usr/share/man/man7/ip.7.gz /usr/share/man/man8/ip.8.gz

Зверніть увагу, whereis також повідомляє про розташування довідкової сторінки.

-----------------------------------------------Робота з файлами--------------------------------------------------------

У Linux є багато команд, які допомагають переглядати вміст файлу, створювати новий файл або порожній файл, змінювати часову мітку файлу, а також переміщувати, видаляти та перейменовувати файл або каталог. Ці команди допомагають керувати даними та файлами та гарантують, що правильні дані доступні у правильному місці.



У цьому розділі ви дізнаєтесь, як керувати файлами.

---------------------------------------------Перегляд файлів-----------------------------------------------------------

Для перегляду файлів можна використовувати такі утиліти командного рядка:

Команда	Використання
cat	Для перегляду невеликих файлів; не забезпечує прокручування назад.
tac	Для перегляду файлу назад, починаючи з останнього рядка.
less	Для перегляду великих файлів, оскільки це програма підкачки. Він зупиняється на кожному екрані, наповненому текстом, надає можливість прокручувати назад і дозволяє здійснювати пошук і переміщатися у файлі.
ПРИМІТКА. Використовуйте символ «/» для пошуку шаблона в напрямку вперед і символ «?» для шаблона к зворотному напрямку. Старіша програма під назвою more все ще використовується, але має менше можливостей: «менше – це more».
tail	За замовчуванням використовується для виведення останніх 10 рядків файлу. Ви можете змінити кількість рядків, ввівши -n 15 або просто -15, якщо ви хочете переглянути останні 15 рядків замість типового.
head	Протилежність tail; за замовчуванням виводить перші 10 рядків файлу.

--------------------------------------------------touch---------------------------------------------------------

touch часто використовується для встановлення або оновлення доступу, зміни та модифікації часу файлів. За замовчуванням він скидає часову мітку файлу відповідно до поточного часу.

Однак ви також можете створити порожній файл за допомогою touch:

$ touch <filename>

Зазвичай це робиться для створення порожнього файлу як заповнювача для подальших цілей.

У touch є кілька корисних параметрів. Наприклад, параметр -t дозволяє встановити певне значення для дати та часу файлу, наприклад:

$ touch -t 12091600 myfile

Це встановлює часову мітку файлу myfile на 16:00 9 грудня (12 09 1600).

------------------------------------------------mkdir та rmdir-----------------------------------------------------

mkdir використовують для створення каталога:

mkdir sampdir
Створює типовий каталог під назвою sampdir у поточному каталозі.
mkdir /usr/sampdir
Створює зразок каталога під назвою sampdir у /usr.
Видалити каталог можна за допомогою команди rmdir. Каталог має бути порожнім, інакше команду не вдасться виконати. Щоби видалити каталог і весь його вміст, потрібно виконати команду rm -rf.

--------------------------Переміщення, перейменування або видалення файлу-------------------------------------------

Зауважте, що команда mv моє подвійне призначення, оскільки може:

просто перейменовувати файл;
переміщати файл в інше місце з можливістю одночасної заміни його назви.
Якщо ви не впевнені у видаленні файлів, які відповідають заданому вами шаблону, завжди добре запускати команду rm інтерактивно (rm -i), щоби підтверджувати дію перед кожним видаленням.

Команда	Використання
mv	Перейменування файлу
rm	Видалення файлу
rm -f	Примусове видалення файлу
rm -i	Інтерактивне видалення файлу

----------------------------------Перейменування або видалення каталога---------------------------------------------

Команда rmdir працює лише з порожніми каталогами; інакше отримаєте повідомлення про помилку.

Хоча введення rm -rf є швидким і простим способом рекурсивного видалення цілого дерева файлової системи, це надзвичайно небезпечно, і команду слід використовувати дуже обережно, особливо адміністратором (пам’ятайте, що рекурсивний спосіб означає перегляд усіх підкаталогів аж до кореня дерева).

Команда	Використання
mv	Перейменувати каталог
rmdir	Видалити порожній каталог
rm -rf	Примусове рекурсивне видалення каталога

-----------------------------------------Модифікація вікна командного рядка-----------------------------------------

Змінна PS1 – це рядок символів, який відображається як підказка в командному рядку. Більшість дистрибутивів установлюють для PS1 відоме значення за замовчуванням, яке підходить у більшості випадків. Однак користувачі можуть забажати, щоб у командному рядку відображалася спеціальна інформація. Наприклад, деякі системні адміністратори вимагають, щоб ім’я користувача та хост-системи відображалися в командному рядку, наприклад:

student@c8 $

Це може бути корисно, якщо ви працюєте в кількох ролях і хочете, щоби вам завжди нагадували про те, хто ви і на якій машині. Наведену вище підказку можна реалізувати, установивши для змінної PS1 значення \u@\h \$.

Наприклад:

$ echo $PS1
\$
$ PS1="\u@\h \$ "
student@c8 $ echo $PS1
\u@\h \$
student@c8 $

Більшість систем налаштовано таким чином, що підказка для суперкористувача є символом решітки (#).

------------------------------------------Лабораторна робота 7.3. Створення, переміщення та видалення файлів----------------

Створіть порожній файл під назвою exercise.txt і перемістіть цей файл у каталог /tmp, використовуючи відносний шлях із каталога Home. Потім видаліть цей файл, вказавши абсолютний шлях.

Перегляньте запропонований розв’язок лабораторної роботи.

Лабораторна робота 7.3. Розв’язок

student:/home/student> touch exercise.txt
student:/home/student> mv exercise.txt ../../tmp
student:/tmp> rm /tmp/exercise.txt

-----------------------------------------Стандартні файлові потоки----------------------------------------------------------

Під час виконання команд за замовчуванням є три стандартні файлові потоки (або дескриптори), які завжди відкриті для використання: стандартний вхід (стандартний вхід або stdin), стандартний вихід (стандартний вихід або stdout) і стандартна помилка (або stderr).

Назва	Символічна назва	Цінність	Приклад
Standard input	stdin	0	клавіатура
Standard output	stdout	1	термінал
Standard error	stderr	2	файл журналу
Зазвичай stdin – це клавіатура, а stdout і stderr виводяться на вашому терміналі. stderr часто перенаправляється до файлу журнала помилок, тоді як stdin надається шляхом вказівки, щоби вхід надходив із файлу або з виводу попередньої команди через канал. stdout також часто перенаправляється у файл. Оскільки stderr – це місце, де пишуться повідомлення про помилки, зазвичай туди нічого не потрапляє.

У Linux усі відкриті файли внутрішньо представлені так званими дескрипторами файлів. Простіше кажучи, вони представлені числами, що починаються з нуля. stdin – дескриптор файлу 0, stdout – дескриптор файлу 1, а stderr – дескриптор файлу 2. Як правило, якщо інші файли відкриваються на додаток до цих трьох, які відкриваються за замовчуванням, вони починатимуться з дескриптора файлу 3 і збільшуватимуться.

У наступних розділах ви побачите приклади, які змінюють те, звідки запущена команда отримує вхідні дані, де записує свій вихід або де виводить діагностичні повідомлення (про помилки).

---------------------------------------------------Перенаправлення введення / виведення---------------------------------------

За допомогою командної оболонки ми можемо перенаправляти три стандартні файлові потоки, щоб отримувати вхідні дані з файлу або іншої команди, а не з клавіатури, і ми можемо записувати вихідні дані та помилки у файли або використовувати їх для надання вхідних даних для наступних команд.

Наприклад, якщо у нас є програма під назвою do_something, яка читає з stdin і записує в stdout і stderr, ми можемо змінити її джерело вхідних даних, використовуючи знак «менше» (<), за яким слідує ім’я файлу, який буде використано для введення даних:

$ do_something < input-file

Якщо ви хочете надіслати вихідні дані у файл, використовуйте знак «більше» (>):

$ do_something > output-file

Оскільки stderr – це не те саме, що stdout, у наведеному вище прикладі повідомлення про помилки все одно відображатимуться у вікнах термінала.

Якщо ви хочете перенаправити stderr в окремий файл, ви використовуєте номер дескриптора файлу stderr (2), знак «більше» (>), а потім ім’я файлу, у якому ви хочете зберігати все, що запущена команда записує в stderr:

$ do_something 2> error-file

ПРИМІТКА. За тією ж логікою do_something 1> output-file – це те саме, що do_something > output-file.

Спеціальний скорочений запис може надсилати будь-що, що записане у файловий дескриптор 2 (stderr), у те саме місце, що й файловий дескриптор 1 (stdout): 2>&1.

$ do_something > all-output-file 2>&1

bash дозволяє простіший синтаксис для наведеного вище:

$ do_something >& all-output-file

-----------------------------------------------------Канали-----------------------------------------------------

Філософія UNIX / Linux полягає в тому, щоби мати багато простих і коротких програм (або команд), які співпрацюють разом заради отримання складних результатів, а не мати одну складну програму з багатьма можливими параметрами та режимами роботи. Для цього широко використовуються канали. Ви можете передавати вихідні дані однієї команди чи програми в іншу як її вхідні дані.

Щоб зробити це, ми використовуємо вертикальну риску «|», символ каналу, між командами:

$ command1 | command2 | command3

Цей приклад представляє те, що ми часто називаємо конвеєром, і дозволяє Linux об’єднувати дії кількох команд в одну. Це надзвичайно ефективно, тому що command2 і command3 не повинні чекати завершення попередніх команд конвеєра, перш ніж вони почнуть зламувати дані у своїх вхідних потоках. На системах з кількома процесорами чи ядрами доступна обчислювальна потужність використовується набагато краще, і все виконується швидше.

Крім того, немає потреби зберігати вихідні дані в (тимчасових) файлах між етапами конвеєра, що заощаджує простір диска і зменшує читання та записування з диска, що часто є найповільнішою перешкодою у виконанні якогось процесу.

--------------------------------------------Пошук файлів---------------------------------------------------------

Можливість швидкого пошуку файлів заощадить ваш час і підвищить продуктивність. Ви можете шукати файли як у вашому каталозі Home, так і в будь-якому іншому каталозі чи місці в системі.

Основними інструментами для цього є утиліти locate та find. Ми також покажемо, як використовувати символи підстановки в bash, щоби вказати будь-який файл, який відповідає цьому узагальненому запиту.

-----------------------------------------------locate------------------------------------------------------------

Утиліта locate виконує пошук, використовуючи переваги попередньо створеної бази даних файлів і каталогів у вашій системі, порівнюючи всі записи, які містять певний рядок символів. Іноді через це може створитися дуже довгий список.

Щоб отримати коротший (і, можливо, більш актуальний) список, ми можемо використати програму grep як фільтр. grep покаже лише ті рядки, які містять один або кілька вказаних рядків, наприклад:

$ locate zip | grep

Команда перерахує всі файли та каталоги з zip і bin у їхніх назвах. Пізніше ми розглянемо grep більш детально. Зверніть увагу на використання символу «|»  для об’єднання двох команд.

locate використовує базу даних, створену відповідною утилітою updatedb. Більшість систем Linux запускають її автоматично раз на день. Однак ви можете оновити її в будь-який час, просто запустивши updatedb з командного рядка як суперкористувач.

find . -name (file) -ls

------------------------------------------Символи підстановки та відповідні імена файлів-------------------------

Ви можете шукати назву файлу, який містить певні символи, використовуючи символи підстановки.

Символ підстановки	Результат
?	Відповідає будь-якому окремому символу
*	Відповідає будь-якому рядку символів
[set]	Відповідає будь-якому символу в наборі символів, наприклад [adf] відповідатиме будь-якому входженню a, d або f
[!set]	Відповідає будь-якому символу, якого немає в наборі символів
Для пошуку файлів за допомогою «?» замініть кожен невідомий символ на «?». Наприклад, якщо ви знаєте, що перші дві літери файлу з розширенням .out «ba», а третьої літери не знаєте, введіть ls ba?.out.

Щоб шукати файли за допомогою «*», замініть невідомий рядок на «*». Наприклад, якщо ви пам’ятаєте лише розширення .out, введіть ls *.out.

du -sh a*
example
lopihara@DESKTOP-2PR8U4H:/var/log$ du -sh a*
24K     alternatives.log
64K     apt
lopihara@DESKTOP-2PR8U4H:/var/log$

student:/tmp/play> ls -a
.	gindxbib	mkfontscale
..	gio-querymodules-64	mkhybrid
[	glib-compile-schemas	mkisofs
a2p	glookbib	mkmanifest
ab	glxgears	mkrfc2734
abrt-action-analyze-backtrace	glxinfo	mkxauth
abrt-action-analyze-c	gmake	mlabel
abrt-action-analyze-ccpp-local	gneqn	mmc-tool
student:/tmp/play> ls g????
gmake gneqn
student:/tmp/play> ls mk*
mkfontscale	mkhybrid	mkisofs	mkmanifest	mkrfc2734	mkxauth
student:/tmp/play> ls g[a-n]???
gmake gneqn
student:/tmp/play>

---------------------------------------Програма find-----------------------------------------------------

find – надзвичайно корисна і часто використовувана допоміжна програма в повсякденному житті системного адміністратора Linux. Вона повертається вниз по дереву файлової системи з будь-якого конкретного каталога (або набору каталогів) і знаходить файли, які відповідають заданим умовам. Шляхом за замовчуванням завжди є поточний робочий каталог.

Наприклад, інколи адміністратори сканують потенційно великі файли ядра (які містять діагностичну інформацію після збою програми), яким більше ніж кілька тижнів, щоби видалити їх.

Також поширене видалення файлів у несуттєвих або застарілих файлах у /tmp (та інших нестабільних каталогах, таких, як ті, що містять кешовані файли), до яких нещодавно не було доступу. Багато дистрибутивів Linux використовують сценарії оболонки, які періодично запускаються (зазвичай через cron), щоби виконати таке очищення.

-----------------------------------------------Використання find------------------------------------------

Якщо аргументи не надано, find перераховує в поточному каталозі всі файли та всі його підкаталоги. Зазвичай до параметрів, які скорочують список, належать -name (перераховувати лише файли з певним шаблоном у назві), -iname (також ігнорувати регістр імен файлів) і -type (який обмежить результати файлами певного вказаного  типу, наприклад, d – для каталога, l – для символічного посилання або f – для звичайного файлу тощо).

Пошук файлів і каталогів під назвою gcc:

$ find /usr -name gcc

Пошук лише за каталогами з назвою gcc:

$ find /usr -type d -name gcc

Пошук лише звичайних файлів під назвою gcc:

$ find /usr -type f -name gcc

-------------------------------------------------Удосконалені параметри пошуку-------------------------------------------

Іншим хорошим використанням find є можливість запускати команди для файлів, які відповідають вашим критеріям пошуку. Для цього використовують параметр -exec.

Знайти та видалити всі файли, які закінчуються на .swp:

$ find -name "*.swp" -exec rm {} ‘;’

{} (фігурні дужки) – це заповнювач, який буде заповнено всіма іменами файлів, отриманими в результаті пошуку, і попередню команду буде виконано для кожного окремо.

Зауважте, що команду потрібно завершувати символом «;» (включно з одинарними лапками) або «\;». Обидва варіанти підходять.

Можна також використати параметр -ok, яка поводиться так само, як -exec, за винятком того, що find запитає дозвіл перед виконанням команди. Це хороший спосіб перевірити ваші результати перед сліпим виконанням будь-яких потенційно небезпечних команд.

----------------------------------------------------Пошук файлів за часом і розміром-------------------------------------

Іноді буває так, що ви бажаєте знайти файли за атрибутами, такими як час їх створення, останнє використання тощо, або за їхнім розміром. Виконувати такий пошук легко.

Щоб знайти файли за часом:

$ find / -ctime 3

Тут -ctime означає, коли метадані inode (тобто власник файлу, дозволи тощо) востаннє змінювалися; часто, але не обов’язково, коли файл було створено вперше.  Ви також можете здійснювати пошук за часом доступу / останнього читання (-atime) або зміненого / останнього запису (-mtime). Число – це кількість днів; воно може бути виражене або числом (n), яке означає саме це значення, +n, що означає більше за це число, або -n, що означає менше за це число. Існують подібні параметри для часу у хвилинах (-cmin, -amin та -mmin).

Щоб знайти файли за розміром:

$ find / -size 0

Зауважте, що за замовчуванням розмір визначено у 512-байтових блоках; ви також можете вказати байти (c), кілобайти (k), мегабайти (M), гігабайти (G) тощо. Як і у випадку з числами часу, розмір файлу також може бути точним числом (n), +n або -n.  Щоб дізнатися більше, зверніться до довідкової сторінки.

Наприклад, знайти файли розміром понад 10 Мбайт і виконати команду для цих файлів:

$ find / -size +10M -exec command {} ‘;’

lopihara@DESKTOP-2PR8U4H:/var/log$ sudo find .
[sudo] password for lopihara:
.
./faillog
./upgrade-policy-changed.log
./unattended-upgrades
./wtmp
./fontconfig.log
./btmp
./lastlog
./ubuntu-advantage.log
./dpkg.log
./journal
./bootstrap.log
./private
./alternatives.log
./apt
./apt/history.log
./apt/eipp.log.xz
./apt/term.log
./dist-upgrade

lopihara@DESKTOP-2PR8U4H:/var/log$ sudo find . -type d
.
./unattended-upgrades
./journal
./private
./apt
./dist-upgrade

sudo find . -type d -maxdepth 1 ховає підкаталоги

show log in all files
lopihara@DESKTOP-2PR8U4H:/var/log$ sudo find . -type f -exec grep -H log {} \;
./dpkg.log:2022-10-25 21:35:02 install login:amd64 <none> 1:4.8.1-2ubuntu2
./dpkg.log:2022-10-25 21:35:02 status half-installed login:amd64 1:4.8.1-2ubuntu2
./dpkg.log:2022-10-25 21:35:02 status unpacked login:amd64 1:4.8.1-2ubuntu2
./dpkg.log:2022-10-25 21:35:02 install logsave:amd64 <none> 1.46.5-2ubuntu1
./dpkg.log:2022-10-25 21:35:02 status half-installed logsave:amd64 1.46.5-2ubuntu1
./dpkg.log:2022-10-25 21:35:02 status unpacked logsave:amd64 1.46.5-2ubuntu1
./dpkg.log:2022-10-25 21:35:03 configure logsave:amd64 1.46.5-2ubuntu1 <none>
./dpkg.log:2022-10-25 21:35:03 status unpacked logsave:amd64 1.46.5-2ubuntu1
./dpkg.log:2022-10-25 21:35:03 status half-configured logsave:amd64 1.46.5-2ubuntu1
./dpkg.log:2022-10-25 21:35:03 status installed logsave:amd64 1.46.5-2ubuntu1
./dpkg.log:2022-10-25 21:35:04 configure login:amd64 1:4.8.1-2ubuntu2 <none>
./dpkg.log:2022-10-25 21:35:04 status unpacked login:amd64 1:4.8.1-2ubuntu2
./dpkg.log:2022-10-25 21:35:04 status half-configured login:amd64 1:4.8.1-2ubuntu2

lopihara@DESKTOP-2PR8U4H:/var/log$ sudo find . -size 0 -ls
       70      0 -rw-rw-r--   1 root     utmp            0 Oct 26 00:34 ./wtmp
       59      0 -rw-rw----   1 root     utmp            0 Oct 26 00:34 ./btmp
       67      0 -rw-r--r--   1 root     root            0 Oct 26 00:35 ./ubuntu-advantage.log


show all files which newer than btmp
lopihara@DESKTOP-2PR8U4H:/var/log$ sudo find . -newer btmp
.
./faillog
./upgrade-policy-changed.log
./fontconfig.log
./lastlog
./ubuntu-advantage.log
./dpkg.log
./journal
./bootstrap.log

---------------------------------Лабораторна робота 7.4. Пошук каталогів і створення символічних посилань---------------

Знайдіть каталог init.d, починаючи з /, а потім створіть символічне посилання з вашого каталога Home на цей каталог.

Зауважте, що цей каталог SysVinit більше не використовується в системах на основі systemd, але зберігається з причин зворотної сумісності.

Перегляньте запропонований розв’язок лабораторної роботи.

Лабораторна робота 7.4. Розв’язок

student:/tmp> find / -type d -name init.d
student:/tmp> cd ~
student:/home/student> ln -s /etc/init.d .

Зауважте, що може бути багато галасу, якщо ви спробуєте переглянути файли та каталоги, які звичайним користувачам заборонено переглядати. Якщо перед командою find вказати sudo, цього не станеться.

--------------------------------------Системи керування пакетами в Linux------------------------------------------------

Основні частини дистрибутива Linux і більша частина його додаткового програмного забезпечення інсталюються через систему керування пакетами. Кожен пакет містить файли й інші інструкції, необхідні для належної роботи одного програмного компонента та взаємодії з іншими компонентами, з яких складається вся система. Пакети можуть залежати один від одного. Наприклад, пакет для вебпрограми, написаний на PHP, може залежати від пакета PHP.



Існують дві великі родини менеджерів пакетів: ті, що базуються на Debian, і ті, які використовують RPM як менеджер пакетів нижчого рівня. Ці дві системи несумісні, але загалом забезпечують однакові функції та задовольняють однакові потреби. Існують і інші системи, якими послуговуються більш спеціалізовані дистрибутиви Linux.

У цьому розділі ви дізнаєтеся, як інсталювати, видаляти або шукати пакети з командного рядка за допомогою цих двох систем керування пакетами.

-----------------------------------Керування пакетами: два рівні---------------------------------------------------------

Обидві системи керування пакетами працюють на двох різних рівнях: інструмент нижчого рівня (наприклад, dpkg або rpm) піклується про деталі розпакування окремих пакетів, виконання сценаріїв, коректну інсталяцію програмного забезпечення, тоді як інструмент вищого рівня (наприклад, apt-get, dnf, yum або zypper) працює з групами пакетів, завантажує пакети від постачальника та визначає залежності.

Здебільшого користувачам потрібно працювати лише з інструментом вищого рівня, який за потреби подбає про виклик інструмента нижчого рівня. Розділення залежностей – це особливо важлива функція інструмента вищого рівня, оскільки він обробляє деталі пошуку та інсталяції кожної залежності за вас. Однак будьте обережні, оскільки інсталяція одного пакета може привести до інсталяції багатьох десятків або навіть сотень залежних пакетів.

--------------------------------------Робота з різними системами керування пакетами--------------------------------------

Advanced Packaging Tool (apt) – це базова система керування пакетами, яка керує програмним забезпеченням у системах на базі Debian. Хоча система формує серверну частину для керування графічними пакетами, таку як Ubuntu Software Center і synaptic, але рідний інтерфейс користувача розміщений у командному рядку з програмами включно з apt (або apt-get) і apt-cache.

dnf – це утиліта командного рядка з відкритим вихідним кодом для керування пакетами RPM-сумісних систем Linux, яка належить до родини Red Hat. dnf має як командний рядок, так і графічний інтерфейс користувача. Fedora та RHEL 8 замінили старішу утиліту yum на dnf, усунувши таким чином багато історичного багажу, а також запровадивши багато гарних нових можливостей. dnf майже сумісний із yum для повсякденних команд.

zypper – це система керування пакетами для родини SUSE / openSUSE, яка також базується на RPM. zypper також дозволяє керувати сховищами з командного рядка. zypper досить проста у використанні та дуже схожа на dnf/yum.

Основні пакетні команди:

Дія	rpm	deb
Інсталяція пакета	rpm -i foo.rpm	dpkg --install foo.deb
Інсталяція пакета, залежності	dnf install foo	apt-get install foo
Видалення пакета	rpm -e foo.rpm	dpkg --remove foo.deb
Видалення пакета, залежності	dnf remove foo	apt-get autoremove foo
Оновлення пакета	rpm -U foo.rpm	dpkg --install foo.deb
Оновлення пакета, залежності	dnf update foo	apt-get install foo
Оновлення всієї системи	dnf update	apt-get dist-upgrade
Показати всі інстальовані пакети	rpm -qa or dnf list installed	dpkg --list
Отримання інформації про пакет	rpm -qil foo	dpkg --listfiles foo
Показати пакет foo	dnf list "foo"	apt-cache search foo
Показати всі доступні пакети	dnf list	apt-cache dumpavail foo
Частиною якого пакета є file?	rpm -qf file	dpkg --search file

examples usage

lopihara@DESKTOP-2PR8U4H:/var/log$ dpkg --list
Desired=Unknown/Install/Remove/Purge/Hold
| Status=Not/Inst/Conf-files/Unpacked/halF-conf/Half-inst/trig-aWait/Trig-pend
|/ Err?=(none)/Reinst-required (Status,Err: uppercase=bad)
||/ Name                          Version                                 Architecture Description
+++-=============================-=======================================-============-================================>
ii  adduser                       3.118ubuntu5                            all          add and remove users and groups
ii  apparmor                      3.0.4-2ubuntu2.1                        amd64        user-space parser utility for Ap>
ii  apport                        2.20.11-0ubuntu82.1                     all          automatically generate crash rep>
ii  apport-symptoms               0.24                                    all          symptom scripts for apport
ii  apt                           2.4.8                                   amd64        commandline package manager
ii  apt-utils                     2.4.8                                   amd64        package management related utili>
ii  base-files                    12ubuntu4.2                             amd64        Debian base system miscellaneous>
ii  base-passwd                   3.5.52build1                            amd64        Debian base system master passwo>
ii  bash                          5.1-6ubuntu1                            amd64        GNU Bourne Again SHell
ii  bash-completion               1:2.11-5ubuntu1                         all          programmable completion for the >
ii  bind9-dnsutils                1:9.18.1-1ubuntu1.2                     amd64        Clients provided with BIND 9
ii  bind9-host                    1:9.18.1-1ubuntu1.2                     amd64        DNS Lookup Utility

lopihara@DESKTOP-2PR8U4H:/var/log$ dpkg --list | grep bzip2
ii  bzip2                         1.0.8-5build1                           amd64        high-quality block-sorting file compressor - utilities

dpkg --listfiles bzip2 | less

---------------------------------------------Керування пакетами вищого рівня з apt у Ubuntu-----------------------------

lopihara@DESKTOP-2PR8U4H:/var/log$ sudo apt-cache search wget2
[sudo] password for lopihara:
wget2 - file and recursive website downloader
wget2-dev - development file for libwget2

lopihara@DESKTOP-2PR8U4H:/var/log$ sudo apt-get install wget2-dev
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following additional packages will be installed:
  libgpgme11 libwget0 wget2
The following NEW packages will be installed:
  libgpgme11 libwget0 wget2 wget2-dev
0 upgraded, 4 newly installed, 0 to remove and 44 not upgraded.
Need to get 289 kB/426 kB of archives.
After this operation, 1174 kB of additional disk space will be used.
Do you want to continue? [Y/n]
Get:1 http://archive.ubuntu.com/ubuntu jammy/universe amd64 libwget0 amd64 1.99.1-2.2 [143 kB]
Get:2 http://archive.ubuntu.com/ubuntu jammy/universe amd64 wget2 amd64 1.99.1-2.2 [95.8 kB]
Get:3 http://archive.ubuntu.com/ubuntu jammy/universe amd64 wget2-dev amd64 1.99.1-2.2 [50.4 kB]
Fetched 289 kB in 1s (307 kB/s)
Selecting previously unselected package libgpgme11:amd64.
(Reading database ... 25259 files and directories currently installed.)
Preparing to unpack .../libgpgme11_1.16.0-1.2ubuntu4_amd64.deb ...
Unpacking libgpgme11:amd64 (1.16.0-1.2ubuntu4) ...
Selecting previously unselected package libwget0.
Preparing to unpack .../libwget0_1.99.1-2.2_amd64.deb ...
Unpacking libwget0 (1.99.1-2.2) ...
Selecting previously unselected package wget2.
Preparing to unpack .../wget2_1.99.1-2.2_amd64.deb ...
Unpacking wget2 (1.99.1-2.2) ...
Selecting previously unselected package wget2-dev.
Preparing to unpack .../wget2-dev_1.99.1-2.2_amd64.deb ...
Unpacking wget2-dev (1.99.1-2.2) ...
Setting up libwget0 (1.99.1-2.2) ...
Setting up libgpgme11:amd64 (1.16.0-1.2ubuntu4) ...
Setting up wget2 (1.99.1-2.2) ...
Setting up wget2-dev (1.99.1-2.2) ...
Processing triggers for man-db (2.10.2-1) ...
Processing triggers for libc-bin (2.35-0ubuntu3.1) ...



lopihara@DESKTOP-2PR8U4H:/var/log$ sudo apt-get remove wget2
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages were automatically installed and are no longer required:
  libgpgme11 libwget0
Use 'sudo apt autoremove' to remove them.
The following packages will be REMOVED:
  wget2 wget2-dev
0 upgraded, 0 newly installed, 2 to remove and 44 not upgraded.
After this operation, 396 kB disk space will be freed.
Do you want to continue? [Y/n] y
(Reading database ... 25304 files and directories currently installed.)
Removing wget2-dev (1.99.1-2.2) ...
Removing wget2 (1.99.1-2.2) ...
Processing triggers for man-db (2.10.2-1) ...

--------------------------------Лабораторна робота 7.5. Інсталяція та видалення пакетів програмного забезпечення-------------------------

Використовуючи систему керування пакетами вищого рівня, яка відповідає вашому дистрибутиву Linux, виконайте такі дії:

Інсталюйте пакет dump у вашу систему.
Видаліть пакет dump з вашої системи.
ПРИМІТКА. Якщо dump уже інстальовано (про це вам буде повідомлено, коли ви спробуєте виконати інсталяцію), тоді виконайте дії в протилежному порядку, тобто видаліть, а потім інсталюйте.

Перегляньте запропонований розв’язок лабораторної роботи.

Лабораторна робота 7.5. Розв’язок

student:/tmp> apt-get install dump
student:/tmp> apt-get remove dump

або

student:/tmp> dnf install dump
student:/tmp> dnf remove dump

або

student:/tmp> yum install dump
student:/tmp> yum remove dump

або

student:/tmp> zypper install dump
student:/tmp> zypper remove dump

----------------------------------------Короткий зміст розділу------------------------------------------

Ви завершили розділ 7. Підсумуймо ключові поняття, які ми розглянули:

Віртуальні термінали (VT) у Linux – це консолі або термінали командного рядка, які використовують підключений монітор і клавіатуру.
Різні дистрибутиви Linux запускають і зупиняють графічний робочий стіл різними способами.
Програма-емулятор термінала на графічному робочому столі працює, емулюючи термінал у вікні на робочому столі.
Система Linux дозволяє входити через текстовий термінал або дистанційно через консоль.
Під час введення пароля на терміналі нічого не друкується, навіть загальні символи, які вказують на те, що ви щось ввели.
Найкращим методом завершення роботи або перезавантаження системи є використання команди shutdown.
Існує два типи шляхів – абсолютні та відносні.
Абсолютне ім’я шляху починається з кореневого каталога і йде за деревом, гілка за гілкою, доки не досягне потрібного каталога або файлу.
Відносний шлях починається з поточного робочого каталога.
Використання жорстких і м’яких (символічних) посилань надзвичайно корисне у Linux.
cd запам’ятовує, де ви були востаннє, і дозволяє повернутися туди за допомогою cd -.
locate виконує пошук у базі даних, щоб знайти всі імена файлів, які відповідають заданому шаблону.
find рекурсивно знаходить файли із заданого каталога або набору каталогів.
find може виконувати команди для файлів, які він перелічує, якщо використовується з параметром -exec.
touch використовують для встановлення часу доступу, зміни та редагування файлів, а також для створення порожніх файлів.
Систему керування пакетами Advanced Packaging Tool (apt) використовують для керування інстальованим програмним забезпеченням у системах на основі Debian.
Ви можете використовувати утиліту керування пакетами командного рядка dnf для дистрибутивів Red Hat Family Linux на основі RPM.
Система керування пакетами zypper базується на RPM і використовується для openSUSE.
