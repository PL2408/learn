--------------------------------Навчальні цілі------------------------------------

використовувати та налаштовувати облікові записи та групи користувачів,
використовувати та встановлювати змінні середовища,
використовувати попередню історію команд оболонки,
використовувати комбінації клавіш,
використовувати та визначати псевдоніми,
використовувати та встановлювати дозволи та право власності на файли.

-------------Ідентифікація поточного користувача----------------------------------

Як ви знаєте, Linux – це багатокористувацька операційна система, тобто в систему можуть увійти кілька користувачів одночасно.

Щоб ідентифікувати поточного користувача, введіть whoami. Щоб отримати список поточних користувачів, введіть who.

Ввівши who з параметром -a, ви отримаєте детальнішу інформацію.

--------------Файли запуску користувача------------------------------------------

У Linux програма командної оболонки (зазвичай bash) використовує один або кілька файлів запуску для конфігурації середовища користувача. Файли в каталозі /etc визначають глобальні параметри для всіх користувачів, тоді як файли ініціалізації в домашньому каталозі користувача можуть містити та / або замінювати глобальні параметри.

Файли запуску можуть робити все, що забажає користувач, у кожній командній оболонці, наприклад:

налаштування prompt;
визначення ярликів і псевдонімів командного рядка;
налаштування текстового редактора за замовчуванням;
установлення шляху для пошуку виконуваних програм.

--------------------------Порядок файлів запуску---------------------------------

Стандартно, коли ви вперше входите в Linux, /etc/profile читається та оцінюється, після чого виконується пошук таких файлів (якщо вони існують) у такому порядку:

~/.bash_profile
~/.bash_login
~/.profile 
де ~/. позначає домашній каталог користувача. Оболонка входу в систему Linux оцінює будь-який файл запуску, на який натрапляє першою, і ігнорує решту. Це означає, що якщо вона знаходить ~/.bash_profile, то ігнорує ~/.bash_login і ~/.profile. Різні дистрибутиви можуть використовувати різні файли запуску.

Однак щоразу, коли ви створюєте нову оболонку, вікно термінала тощо, ви не виконуєте повний вхід у систему; читається та оцінюється лише файл із назвою ~/.bashrc. Хоча цей файл не читається та не оцінюється разом з оболонкою входу, більшість дистрибутивів та / або користувачів включають файл ~/.bashrc з одного з трьох файлів запуску, що належать користувачам.

Найчастіше користувачі використовують лише ~/.bashrc, оскільки він викликається щоразу, коли запускається нова оболонка командного рядка або інша програма запускається з вікна термінала, тоді як інші файли читаються та виконуються лише тоді, коли користувач вперше входить у систему.

Останні дистрибутиви іноді навіть не мають .bash_profile та / або .bash_login, а деякі містять лише .bashrc.

--------------------------Створення псевдонімів----------------------------------

Ви можете створювати власні команди або змінювати поведінку вже наявних, створюючи псевдоніми. Найчастіше ці псевдоніми розміщуються у вашому файлі ~/.bashrc, тому вони доступні для будь-якої командної оболонки, яку ви створюєте. unalias видаляє псевдонім.

Якщо ввести псевдонім без аргументів, буде показано поточні визначені псевдоніми.

Будь ласка, зверніть увагу, що по обидва боки від знака рівності не має бути пробілів, а псевдонім, якщо він містить пробіли, потрібно взяти в одинарні або подвійні лапки.

-------------------------Користувачі та групи: основи----------------------------

Усім користувачам Linux призначається унікальний ідентифікатор користувача (unique user ID (uid)), який є цілим числом; звичайні користувачі починаються з uid 1000 або більше.

Linux використовує групи, щоб організувати користувачів. Групи – це набори облікових записів із певними спільними дозволами. Керування членством у групах здійснюється за допомогою файлу /etc/group, у якому показано список груп та їхніх учасників. За замовчуванням кожен користувач належить до основної або первинної групи. Коли користувач входить, членство в групі встановлюється для його первинної групи, і всі учасники мають однаковий рівень доступу та привілеїв. Дозволи для різних файлів і каталогів можна змінювати на рівні групи.

Користувачі також мають один або кілька ідентифікаторів групи (group IDs (gid)), зокрема стандартний, який збігається з ідентифікатором користувача. Ці номери пов’язані з іменами через файли /etc/passwd та /etc/group. Групи потрібні для того, щоби певний набір користувачів, які мають спільні інтереси, мав однакові права доступу, привілеї, безпеку. Права доступу до файлів (і пристроїв) надаються на основі користувача та групи, до якої він належить.

Наприклад, /etc/passwd може містити george:x:1002:1002:George Metesky:/home/george:/bin/bash, а /etc/group може містити george:x:1002.

-------------Додавання та видалення користувачів----------------------------------

Дистрибутиви мають прості графічні інтерфейси для створення та видалення користувачів і груп, а також для керування членством у групах. Однак часто корисно робити це з командного рядка або зі сценаріїв оболонки. Лише користувач root (адміністратор) може додавати та видаляти користувачів і групи.

Додавання нового користувача виконується за допомогою useradd, а видалення користувача, який уже існує, – за допомогою userdel. У найпростішому вигляді обліковий запис для нового користувача bjmoose буде створено за допомогою:

$ sudo useradd bjmoose

який за замовчуванням установлює домашній каталог у /home/bjmoose, заповнює його основними файлами (скопійованими з /etc/skel) і додає рядок до /etc/passwd, наприклад:

bjmoose:x:1002:1002::/home/bjmoose:/bin/bash

і встановлює оболонку за замовчуванням на /bin/bash. Видалити обліковий запис користувача так само просто, як ввести userdel bjmoose. Однак на каталог /home/bjmoose це не вплине. Це може бути корисним, якщо це тимчасова інактивація. Щоби видалити каталог home під час видалення облікового запису, потрібно використати параметр -r для userdel.

Введення id без аргументу видає інформацію про поточного користувача:

$ id

uid=1002(bjmoose) gid=1002(bjmoose) groups=106(fuse),1002(bjmoose)

Якщо як аргумент ввести ім’я іншого користувача, id повідомить інформацію про цього іншого користувача.

--------------------------Додавання та видалення груп-----------------------------

Додавання нової групи виконується за допомогою groupadd:

$ sudo /usr/sbin/groupadd anewgroup

Групу можна видалити за допомогою:

$ sudo /usr/sbin/groupdel anewgroup

Додавання користувача до групи, яка вже існує, виконується за допомогою usermod. Наприклад, вам треба спочатку подивитися, до яких груп уже належить користувач:

$ groups rjsquirrel
rjsquirrel : rjsquirrel

а потім додайте нову групу:

$ sudo /usr/sbin/usermod -a -G anewgroup rjsquirrel

$ groups rjsquirrel
rjsquirrel: rjsquirrel anewgroup

Ці утиліти оновлюють /etc/group за потреби. Обов’язково використовуйте параметр -a для додавання, щоби не видалити групи, які вже існують. groupmod можна використовувати для зміни властивостей групи, таких як ідентифікатор групи (gid), за допомогою параметра -g або її імені за допомогою параметра -n.

Видалити користувача з групи дещо складніше. Параметр -G для usermod має показати повний список груп. Отже, якщо ви введете:

$ sudo /usr/sbin/usermod -G rjsquirrel rjsquirrel

$ groups rjsquirrel
rjsquirrel : rjsquirrel

залишиться лише група rjsquirrel.

-------------------------Обліковий запис суперкористувача-------------------------

Обліковий запис суперкористувача дуже потужний і має повний доступ до системи. В інших операційних системах його часто називають обліковим записом адміністратора; у Linux – обліковим записом суперкористувача. Ви маєте бути надзвичайно обережними, перш ніж надавати користувачеві доступ рівня суперкористувача. Це майже ніколи не виправдано. Зовнішні атаки часто складаються з прийомів, спрямованих на підвищення облікового запису суперкористувача.


Однак ви можете за допомогою sudo призначити більш обмежені привілеї обліковим записам користувачів:

тільки на тимчасовій основі;
лише для певної підмножини команд.

--------------------------------su і sudo-----------------------------------------

ризначаючи підвищені привілеї, ви можете використовувати команду su (змінити або замінити користувача), щоби запустити нову оболонку, що працює від імені іншого користувача (треба ввести пароль користувача, яким ви стаєте). Найчастіше цей інший користувач – root, і нова оболонка дозволяє використовувати підвищені привілеї до виходу. Майже завжди погано (як для безпеки, так і для стабільності) використовувати su, щоби стати root. Можливими неприємними наслідками можуть стати видалення важливих файлів із системи та порушення безпеки.

Краще та безпечніше надавати привілеї за допомогою sudo. За замовчуванням sudo має бути ввімкнено для кожного користувача. Однак у деяких дистрибутивах (наприклад, Ubuntu) sudo ввімкнено за замовчуванням принаймні для одного основного користувача або дано як вибір під час інсталяції.

У розділі 18 «Принципи локальної безпеки» ми детально опишемо та порівняємо su та sudo.

-------------------Підвищення до облікового запису суперкористувача--------------

Щоби тимчасово стати суперкористувачем для ряду команд, ви можете ввести su, після чого вам буде запропоновано ввести пароль суперкористувача.

Щоби виконати лише одну команду з привілеєм суперкористувача, введіть sudo <command>. Після виконання команди ви повернетеся до нормального непривілейованого користувача.

Конфігураційні файли sudo зберігаються у файлі /etc/sudoers і в каталозі /etc/sudoers.d/. За замовчуванням каталог sudoers.d порожній.

--------------------Лабораторна робота 12.1. Розгортання псевдонімів-------------

Вводити часто повторювані довгі команди й імена файлів знову нудно, що призводить до багатьох дрібних помилок.

Розгортання псевдонімів дозволяє нам визначати ярлики, які полегшують біль від набору тексту.

Припустимо, що ви – член команди, яка працює в загальному спільному каталозі вашого проєкту. Цей каталог розміщено в /home/staff/RandD/projects/projectX/src.

Коли ви працюєте над Project X, вам часто потрібно створювати та змінювати файли в цьому каталозі. На введення

cd /home/staff/RandD/projects/projectX/src

часу потрібно небагато, проте згодом це втомлює.

Визначте та використовуйте псевдонім під назвою «projx», щоби виконати наведену вище команду cd за вас.

Перегляньте запропонований розв’язок лабораторної роботи.

Лабораторна робота 12.1. Розв’язок

Рядок псевдоніма:

student:/tmp> alias projx=‘cd /home/staff/RandD/projects/projectX/src’

Зауважте, що ви можете використовувати подвійні лапки замість одинарних лапок або взагалі не використовувати лапки, оскільки у визначеному вами псевдонімі немає пробілу. І тепер, щоби перейти до каталога, вам потрібно ввести лише:

student:/tmp> projx

Щоби зробити псевдонім постійним, помістіть його у свій файл $HOME/.bashrc.

-----------------------Змінні середовища--------------------------------------------

Змінні середовища – це величини, які мають певні значення, що можуть використовуватися командною оболонкою, такою як bash, або іншими утилітами й програмами. Деяким змінним середовища надається система попередньо встановлених значень (які зазвичай можна змінити), тоді як інші встановлюються безпосередньо користувачем або в командному рядку, або в сценаріях запуску та інших.

Змінна середовища – це насправді просто рядок символів, який містить інформацію, що використовується однією або кількома програмами. Існує кілька способів перегляду значень поточних установлених змінних середовища; можна ввести set, env або export. Залежно від стану вашої системи, set може вивести набагато більше рядків, ніж два інші методи.

---------------------Налаштування змінних середовища--------------------------------

За замовчуванням змінні, створені у сценарії, доступні лише для поточної оболонки; дочірні процеси (підоболонки) не матимуть доступу до значень, які були встановлені або змінені. Щоби дозволити дочірнім процесам переглядати значення, потрібно використовувати команду export.

Завдання	Команда
Показати значення певної змінної	echo $SHELL
Експорт нового значення змінної	export VARIABLE=value (або VARIABLE=value; export VARIABLE)
Додайте змінну назавжди	Відредагуйте ~/.bashrc і додайте рядок export VARIABLE=value<br/ > Введіть source ~/.bashrc або просто . ~/.bashrc (крапка ~/.bashrc); або просто запустіть нову оболонку, ввівши bash
Ви також можете налаштувати змінні середовища для одноразової передачі команді:

$ SDIRS=s_0* KROOT=/lib/modules/$(uname -r)/build make modules_install

що передає значення змінних середовища SDIRS і KROOT до команди make modules_install.

----------------------------------Змінна HOME---------------------------------------

HOME – це змінна середовища, яка представляє домашній каталог (або логін) користувача. cd без аргументів змінить поточний робочий каталог на значення HOME. Зверніть увагу, що тильду (~) часто використовують як абревіатуру для $HOME. Таким чином, cd $HOME і cd ~ – це повністю еквівалентні оператори.

Команда	Пояснення
$ echo $HOME
/home/me
$ cd /bin	Показує значення змінної середовища HOME, потім змінює каталог (cd) на /bin.
$ pwd
/bin	Використовуйте print (або present) робочий каталог (pwd), щоб дізнатися. Як і очікувалося, /bin.
$ cd	Змінює каталог без аргументу...
$ pwd
/home/me	...повертає нас до HOME, як бачите.
Це продемонстровано на знімку екрана.

------------------------------Змінна PATH--------------------------------------------

PATH – це впорядкований список каталогів (шлях), який сканується, коли дається команда для пошуку відповідної програми або сценарію для запуску. Кожен каталог у шляху відокремлюється двокрапкою «:». Пуста (порожня) назва каталога (або «./») вказує на поточний каталог у будь-який момент часу.

:path1:path2
path1::path2
У прикладі :path1:path2 перед першою двокрапкою «:» є нульовий каталог. Аналогічно, для path1::path2 є нульовий каталог між path1 і path2.

Особистий каталог bin до вашого шляху: 

$export PATH=$HOME/bin:$PATH
$ echo $PATH
/home/student/bin:/usr/local/bin:/usr/bin:/bin/us

---------------------------------Змінна SHELL--------------------------------------

Змінна середовища SHELL вказує на командну оболонку користувача за замовчуванням (програма, яка обробляє все, що ви вводите у командному вікні, зазвичай bash) і містить повний шлях до оболонки:

$ echo $SHELL
/bin/bash
$

-------------------------------------Юніт------------------------------------------

Оператор Prompt Statement (PS) використовується для налаштування рядка promprt у вікнах термінала для відображення потрібної інформації.

PS1 – основна змінна prompt, яка керує виглядом командного рядка. До PS1 можуть бути включені такі спеціальні символи:

\u – ім’я користувача,
\h – ім’я хоста,
\w – поточний робочий каталог,
\! – історичний номер цієї команди,
\d – дата.

Під час використання їх треба взяти в одинарні лапки, як показано у прикладі:

$ echo $PS1
$
$ export PS1=‘\u@\h:\w$ ‘
student@example.com:~$ # new prompt

Щоби скасувати зміни:

student@example.com:~$ export PS1=‘$ ‘
$

Ще краще було би спочатку зберегти попередній prompt, а потім відновити:

$ OLD_PS1=$PS1

Змініть prompt і поверніть за допомогою:

$ PS1=$OLD_PS1
$
--------Лабораторна робота 12.2. Додавання /tmp до вашого шляху------------------

Створіть невеликий файл /tmp/ls, який містить лише рядок:

echo HELLO, this is the phony ls program.

Потім зробіть його виконуваним, виконавши:

$ chmod +x /tmp/ls

Додайте /tmp до свого шляху, щоби пошук здійснювався лише після того, як буде розглянуто ваш звичайний шлях. Введіть ls і подивіться, яка програма запущена: /bin/ls чи /tmp/ls?
Попередньо додайте /tmp до вашого шляху, щоби його шукали перед вашим звичайним шляхом. Ще раз введіть ls і подивіться, яка програма запущена: /bin/ls чи /tmp/ls?
З яких міркувань безпеки можна змінювати шлях таким чином?

Перегляньте запропонований розв’язок лабораторної роботи.

Лабораторна робота 12.2. Розв’язок

Спочатку створіть фальшиву ls програму за допомогою редактора або просто виконавши такі дії:

student:/tmp>echo "echo HELLO, this is the phony ls program." > /tmp/ls
student:/tmp>chmod +x /tmp/ls

Наступні два кроки було би непогано виконувати в іншому вікні термінала або просто запустити нову оболонку, щоби зміни не зберігалися в командах, виданих пізніше. Ви можете запустити нову оболонку, просто ввівши bash.

student:/tmp>bash
student:/tmp>PATH=$PATH:/tmp
student:/tmp>ls /usr
bin etc games include lib lib64 libexec local sbin share src tmp
student:/tmp>exit
student:/tmp>bash
student:/tmp>PATH=/tmp:$PATH
student:/tmp>ls /usr
HELLO, this is the phony ls program.
student:/tmp>exit
Зверніть увагу, що другий варіант дуже небезпечний, – це легкий спосіб вставити програму Trojan Horse; якщо хтось зможе розмістити шкідливу програму в /tmp, вони можуть обманом змусити вас запустити її.

----------------------------------Лабораторна робота 12.3. Зміна командного рядка-----------------------------------------

Приємно, коли поточний робочий каталог є частиною prompt, щоби можна було отримувати інформацію, не вводячи щоразу pwd.

Якщо ви часто працюєте на кількох комп’ютерах, особливо якщо ви підключаєтесь до мережі за допомогою ssh, дуже зручно, щоб ім’я комп’ютера було частиною prompt.

Додайте свій поточний робочий каталог у командний рядок.
Введіть назву свого комп’ютера (машини) у запиті.
Введіть поточний каталог і ім’я комп’ютера в запит.
Як зробити так, щоби щоразу, коли ви запускаєте командну оболонку bash, це була prompt?

Перегляньте запропонований розвʼязок лабораторної роботи.

Лабораторна робота 12.3. Розвʼязок

$ echo $PWD
/tmp
$ PS1=‘\w>‘
/tmp>
PS1=‘\h>‘
student>
PS1=‘\h:\w>‘
student:/tmp

-----------------------------------Відкликання попередніх команд---------------------------------------------

bash відстежує попередньо введені команди та оператори в буфері історії. Ви можете викликати раніше використані команди з допомогою курсорних клавіші «Вгору» та «Вниз». Щоби переглянути список раніше виконаних команд, можете ввести history в командному рядку.

Список команд відображається з останньою командою в списку. Ця інформація зберігається в ~/.bash_history. Якщо у вас відкрито кілька терміналів, команди, введені в кожному сеансі, не зберігаються, доки сеанс не завершиться.

----------------------------------------Використання змінних середовища історії------------------------------

Щоб отримати інформацію про файл history, можна використовувати кілька пов’язаних змінних середовища.

HISTFILE – розташування файлу history.
HISTFILESIZE – максимальна кількість рядків у файлі history (за замовчуванням 500).
HISTSIZE – максимальна кількість команд у файлі history.
HISTCONTROL – як зберігаються команди.
HISTIGNORE – які командні рядки можна не зберігати.
Щоб отримати повний опис використання цих змінних середовища, перегляньте man bash.

------------------------------Пошук і використання попередніх команд------------------------------------------

Спеціальні клавіші для виконання різних завдань.

Клавіша	Використання
Курсорні клавіші «Вгору» / «Вниз»	Переглянути список команд, які були виконані раніше
!! (вимовляється як бенг-бенг)	Виконати попередню команду
CTRL-R	Пошук раніше використаних команд
Якщо ви хочете викликати команду зі списку історії, але не хочете натискати курсорну клавішу кілька разів, можете натиснути CTRL+R, щоби виконати інтелектуальний пошук у зворотному напрямку.

Коли ви починаєте вводити текст, пошук повертається у зворотному порядку до першої команди, яка відповідає введеним літерам. Вводячи більше послідовних літер, ви робите відповідність дедалі точнішою.

Нижче наведено приклад того, як можна використовувати команду CTRL+R для пошуку в історії команд:

$ ^R                                                    (усе це відбувається в 1 рядку)
(reverse-i-search)’s’: sleep 1000    (Пошук ‘s’; знайдено "sleep")
$ sleep 1000                                     (Натиснуто Enter, щоб виконати шукану команду)

------------------------------Виконання попередніх команд-----------------------------

У таблиці описано синтаксис для виконання раніше використаних команд:

Синтаксис	Завдання
!	Починає заміну історії
!$	Посилання на останній аргумент у рядку
!n	Звернення до n-го командного рядка
!string	Звернення до останньої команди, яка починається з рядка
Усі заміни історії починаються з символу «!». Під час введення команди: ls -l /bin /etc /var, !$ посилатиметься на /var – останній аргумент команди.

Ось іще приклади:

$ history

echo $SHELL
echo $HOME
echo $PS1
ls -a
ls -l /etc/ passwd
sleep 1000
history
$ !1                             (виконати команду №1 вище)
echo $SHELL
/bin/bash

$ !sl                            (виконати команду, яка починається з "sl")
sleep 1000
$

---------------------------------Гарячі клавіші---------------------------------------

Ви можете використовувати комбінації клавіш для швидкого виконання різних завдань. У таблиці наведено деякі з цих комбінацій клавіш і їх використання. Зауважте, що регістр гарячої клавіші не має значення, тобто натискання CTRL+a – це те саме, що натискання CTRL+A.

Гарячі клавіші	Завдання
CTRL+L	Очищає екран
CTRL+D	Вихід із поточної оболонки
CTRL+Z	Переводить поточний процес у призупинений фон
CTRL+C	Знищує поточний процес
CTRL+H	Працює так само, як Backspace
CTRL+A	Перехід на початок рядка
CTRL+W	Видаляє слово перед курсором
CTRL+U	Видаляє від початку рядка до позиції курсору
CTRL+E	Перехід до кінця рядка
Tab	Автоматично заповнює файли, каталоги та двійкові файли

--------------------------------Лабораторна робота 12.4. Команда history--------------

Ви вже достатньо довго працюєте з Linux і ввели приблизно 100 команд в одній командній оболонці bash. Ви недавно використали нову команду, але забули її точну назву. Або, можливо, це була досить складна команда з купою параметрів і аргументів, і ви не хочете знову проходити через схильний до помилок процес з’ясування того, що вводити.

Як з’ясувати, яка була команда?

Ви знайдете команду в історії, але як легко ввести команду знову, не вводячи її всю до prompt?

Перегляньте запропонований розвʼязок лабораторної роботи.

Лабораторна робота 12.4. Розвʼязок

Команда history – це спосіб відобразити команди, які ви ввели:

student:/tmp> history

1 cd /
2 ls
3 cd
4 pwd
5 echo $SHELL
6 ls /var/
7 ls /usr/bin
8 ls /usr/local/bin
9 man fstab
10 ls
. . .

Щоб повторно запустити попередню команду, у вас є кілька варіантів. Припустімо, ви хочете повторно запустити команду man, яку ви запустили під час першого входу. Ви можете ввести:

student:/tmp> !9

щоб повторно запустити команду, вказану під номером 9. Якщо це була єдина команда man, яку ви ввели, ви також можете ввести:

student:/tmp> !man

Тепер ви пам’ятаєте назву команди, яку ввели. Нарешті, якщо ви ввели кілька команд man, ви можете використати CTRL+R для пошуку у своїй історії, щоб знайти конкретну команду man, яку ви хочете повторно запустити, а потім просто натиснути Return, щоб виконати її.

--------------------------------Режими права доступу до файлів і chmod----------------------------

Файли мають три типи дозволів: читання (r), запис (w), виконання (x). Зазвичай вони представлені як rwx. Ці дозволи впливають на три групи власників: користувач / власник (u), група (g) та інші (o).

У результаті у вас є такі три групи по три дозволи:

rwx: rwx: rwx
  u:     g:    o

Існує кілька різних способів використання chmod. Наприклад, щоб надати власнику та іншим дозвіл на виконання та видалити дозвіл на груповий запис:

$ ls -l somefile
-rw-rw-r-- 1 student student 1601 Mar 9 15:04 somefile
$ chmod uo+x,g-w somefile
$ ls -l somefile
-rwxr--r-x 1 student student 1601 Mar 9 15:04 somefile

де u означає користувача (user), o означає інший (other), а g означає групу (group).

Такий тип синтаксису може бути складним для введення та запам’ятовування, тому часто використовується скорочення, яке дозволяє встановити всі дозволи за один крок. Це робиться за допомогою простого алгоритму, і однієї цифри достатньо, щоб визначити всі три біти дозволу для кожної сутності. Ця цифра – це сума:

4, якщо потрібен дозвіл на читання,
2, якщо потрібен дозвіл на запис,
1, якщо потрібен дозвіл на виконання.
Таким чином, 7 означає читання / запис / виконання, 6 означає читання / запис, а 5 означає читання / виконання.

Коли ви застосовуєте це до команди chmod, ви повинні вказати три цифри для кожного ступеня свободи, наприклад:

$ chmod 755 somefile
$ ls -l somefile
-rwxr-xr-x 1 student student 1601 Mar 9 15:04 somefile

--------------------------------Приклад chown----------------------------------

Розглянемо приклад зміни права власності на файл за допомогою chown, як показано на знімку екрана.

Спочатку створюємо два порожні файли за допомогою touch. Зауважте, що для зміни власника file2 на root потрібно sudo. Друга команда chown змінює і власника, і групу одночасно!

І лише суперкористувач може видалити файли.

------------------------------Короткий зміст розділу---------------------------

Ви завершили розділ 12. Підсумуймо основні розглянуті поняття:

Linux – це багатокористувацька система.
Щоб знайти поточних користувачів, ви можете скористатися командою who.
Щоб знайти поточний ідентифікатор користувача, ви можете скористатися командою whoami.
Обліковий запис суперкористувача має повний доступ до системи. Немає сенсу надавати користувачеві повний доступ суперкористувача.
За допомогою команди sudo можна тимчасово призначити права root обліковим записам звичайних користувачів.
Програма оболонки (bash) використовує кілька файлів запуску для створення середовища користувача. Кожен файл по-своєму впливає на інтерактивне середовище. /etc/profile надає глобальні налаштування.
Переваги файлів запуску полягають у тому, що вони налаштовують prompt користувача, установлюють тип термінала користувача, установлюють ярлики командного рядка та псевдоніми, установлюють текстовий редактор за замовчуванням тощо.
Змінна середовища – це рядок символів, який містить дані, що використовуються однією або кількома програмами. Вбудовані змінні оболонки можна налаштувати відповідно до ваших вимог.
Команда history викликає список попередніх команд, які можна редагувати та повторювати.
У Linux різні комбінації клавіш можна використовувати в командному рядку замість довгих справжніх команд.
Ви можете налаштувати команди, створивши псевдоніми. Додавання псевдоніма до ~/.bashrc зробить його доступним для інших оболонок.
Права доступу до файлу можна змінити, ввівши chmod permissions filename.
Право власності на файл можна змінити, ввівши chown owner filename.
Право власності на групу файлів змінюється введенням chgrp group filename.

chmod uo+x,g-w sample2.sh