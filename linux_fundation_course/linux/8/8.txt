------------------------------Навчальні цілі-----------------------------------

Після проходження цього розділу ви зможете:

опиcувати, що таке процес, і розрізняти типи процесів;
перелічувати атрибути процесу;
керувати процесами за допомогою ps і top;
розуміти використання середніх значень навантаження та інших показників процесу;
керувати процесами, переводячи їх у фоновий режим і повертаючи на передній план;
використовувати at, cron і sleep, щоби запланувати процеси в майбутньому або призупинити їх.

-------------------------Що таке процес?---------------------------------------

Процес – це просто екземпляр одного або кількох пов’язаних завдань (потоків), які виконуються на вашому комп’ютері. Це не те саме, що програма чи команда.  Одна команда може запускати кілька процесів одночасно. Деякі процеси незалежні один від одного, а інші пов’язані. Збій одного процесу може вплинути або не вплинути на інші, запущені в системі.

Процеси використовують багато системних ресурсів, таких як пам’ять, цикли ЦП (центрального процесора) і периферійні пристрої, такі як мережеві карти, жорсткі диски, принтери та дисплеї. Операційна система (особливо ядро) відповідає за розподіл належної частки цих ресурсів для кожного процесу та забезпечення загального оптимізованого використання системи.

-------------------------Типи процесів-----------------------------------------

Вікно термінала (один із видів командної оболонки) – це процес, який виконується стільки, скільки потрібно. Це дозволяє користувачам виконувати програми та отримувати доступ до ресурсів в інтерактивному середовищі. Ви також можете запускати програми у фоновому режимі, що означає, що вони від’єднуються від оболонки.

Процеси можуть бути різних типів відповідно до завдання, що виконується.  Ось кілька різних типів процесів (опис і приклад):

Тип процесу	                                                          Опис	                                                                                  Приклад
Інтерактивні процеси	Мають бути запущені користувачем або через командний рядок, або через графічний інтерфейс, такий як піктограма або вибір меню.	
                                                                                                                                                        bash, firefox, top

Пакетні процеси	Автоматичні процеси, які плануються з термінала, а потім відключаються від нього. Ці завдання ставляться в чергу та працюють за принципом FIFO (першим прийшов, першим вийшов).	                                                                                                                               updatedb, ldconfig

Daemons Демони	Процеси сервера, які працюють безперервно. Багато з них запускаються під час запуску системи, а потім очікують запиту користувача або системи, який вказує на потребу в їхній службі.	                                                                                                                              httpd, sshd, libvirtd

Threads Потоки	Легкі процеси. Це завдання, які виконуються під егідою основного процесу, спільно використовують пам’ять та інші ресурси, але плануються та виконуються системою на індивідуальній основі. Окремий потік може закінчитися, не припиняючи весь процес, і процес може створювати нові потоки в будь-який час. Багато нетривіальних програм є багатопоточними.	                                                                                                                     firefox, gnome-terminal-server

Потоки ядра	Завдання ядра, які користувачі не запускають і не завершують, і які мало контролюють. Вони можуть виконувати такі дії, як переміщення потоку з одного ЦП на інший або перевірка виконання операцій введення / виведення на диск.	                                                                              kthreadd, migration, ksoftirqd

-------------------------Планування процесів і стани----------------------------

Критична функція ядра, яка називається планувальником, постійно вмикає та вимикає процеси ЦП, розподіляючи час відповідно до відносного пріоритету, скільки часу потрібно та скільки вже надано для завдання.

Коли процес перебуває в так званому запущеному стані, це означає, що він або зараз виконує інструкції на ЦП, або чекає на надання частки часу (проміжок часу), щоб він міг їх виконати. Усі процеси в цьому стані перебувають у черзі виконання, а на комп’ютері з кількома ЦП або ядрами є черга виконання на кожному.

Однак інколи процеси переходять у так званий стан сну. Зазвичай вони чекають, що щось станеться, перш ніж з’явиться можливість продовжити роботу (наприклад, коли користувач щось набере). У цьому випадку кажуть, що процес стоїть у черзі очікування.

Існують інші стани процесу (вони виникають не так часто), особливо коли процес завершується. Іноді дочірній процес завершується, а батьківський процес не запитує про його стан. Тоді кажуть, що такий процес відбувається в стані зомбі: він насправді не живий, але все ще відображається в списку процесів системи.

------------------------Ідентифікатори процесів і потоків-----------------------

У будь-який момент часу завжди виконується кілька процесів.  Операційна система відстежує їх, призначаючи кожному унікальний ідентифікатор процесу (PID). PID використовується для відстеження стану процесу, використання ЦП, використання пам’яті, точного розташування ресурсів у пам’яті й інших характеристик.

Нові PID зазвичай призначаються в порядку зростання в міру появи процесів. Тобто PID 1 позначає процес init (процес ініціалізації), а наступним процесам поступово присвоюються вищі номери.

У таблиці наведені типи PID та їхні описи:

Тип ID	                                                                                      Опис
Ідентифікатор процесу (PID)	                                                    Унікальний ідентифікаційний номер процесу
Ідентифікатор батьківського процесу (PPID)	                                    Процес (батьківський), який запустив цей процес. Якщо «батько» помирає, PPID асоціюватиметься із «прийомним батьком»; на останніх ядрах це kthreadd, PPID якого 2.
Ідентифікатор потоку (TID)	Ідентифікаційний номер потоку.                      Це те саме, що PID для однопотокових процесів. Для багатопотокового процесу кожен потік має однаковий PID, проте унікальний TID.

------------------------------Припинення процесу--------------------------------

У якийсь момент одна з ваших програм може перестати працювати належним чином. Як ви це виправите?

Щоби припинити процес, ви можете ввести kill -SIGKILL <pid> або kill -9 <pid>.

Однак зверніть увагу, що ви можете «вбити» лише власні процеси. Ті, що належать іншому користувачеві, заборонено чіпати, якщо ви не суперкористувач.

----------------------Ідентифікатори користувача та групи-----------------------

Користувачі можуть отримати доступ до системи одночасно, і кожен користувач може запустити кілька процесів. Операційна система ідентифікує користувача, який починає процес, за справжнім ідентифікатором користувача (Real User ID, RUID), призначеним йому.

Користувач, який визначає права доступу для користувачів, ідентифікується за ефективним ідентифікатором користувача (Effective User ID, EUID). EUID може збігатися з RUID, а може і не збігатися.

Kористувачів можна розділити на різні групи. Кожна група ідентифікується за справжнім ідентифікатором групи (Real Group ID, RGID). Права доступу до групи визначаються ефективним ідентифікатором групи (Effective Group ID, EGID). Кожен користувач може бути членом однієї або кількох груп.

Зазвичай ми ігноруємо ці деталі та просто говоримо про ідентифікатор користувача (UID) та ідентифікатор групи (GID).

-----------------------Докладніше про пріоритети--------------------------------

У будь-який момент часу в системі виконується багато процесів (тобто в черзі виконання). Однак ЦП може одночасно виконувати лише одне завдання, так само, як автомобіль може мати лише одного водія одночасно. Деякі процеси важливіші за інші, тому Linux дозволяє встановлювати пріоритет процесів і керувати ними. Процеси з вищим пріоритетом отримують переважний доступ до ЦП.

Пріоритет для процесу можна встановити, вказавши значення nice, або niceness, для процесу. Що менше значення nice, то вищий пріоритет. Низькі значення призначаються важливим процесам, тоді як високі значення призначаються процесам, які можуть чекати довше. Процес із високим значенням nice дозволяє іншим процесам виконуватися першими. У Linux значення nice -20 означає найвищий пріоритет, а +19 – найнижчий. Звучить доволі незвично, проте така відповідність (що кращий процес, то нижчий пріоритет) існує з перших днів UNIX.

Ви також можете призначити так званий пріоритет у реальному часі (real-time priority) для завдань, чутливих до часу, таких як керування машинами через комп’ютер або збір вхідних даних. Це просто дуже високий пріоритет, і його не слід плутати з тим, що називається жорстким режимом реального часу, який відрізняється концептуально і більше пов’язаний із забезпеченням виконання роботи в межах чітко визначеного часового вікна.

lopihara@DESKTOP-2PR8U4H:~$ cd /mnt/
lopihara@DESKTOP-2PR8U4H:/mnt$ ps
  PID TTY          TIME CMD
    9 pts/0    00:00:00 bash
  190 pts/0    00:00:00 ps
lopihara@DESKTOP-2PR8U4H:/mnt$ ps lf
F   UID   PID  PPID PRI  NI    VSZ   RSS WCHAN  STAT TTY        TIME COMMAND
4  1000     9     8  20   0   6344  5304 do_wai Ss   pts/0      0:00 -bash
0  1000   191     9  20   0   7480  1564 -      R+   pts/0      0:00  \_ ps lf
lopihara@DESKTOP-2PR8U4H:/mnt$ renice +5 9
9 (process ID) old priority 0, new priority 5

----------------------------Середні навантаження---------------------------------

Середнє навантаження – це середнє число навантаження за певний період часу. Воно враховує такі процеси:

активно працює на ЦП;
вважається придатним для роботи, але очікує, поки ЦП стане доступним;
режим сну: тобто очікування, поки якийсь ресурс (зазвичай введення / виведення) стане доступним.
ПРИМІТКА. Linux відрізняється від інших UNIX-подібних операційних систем тим, що зараховує сюди процеси в режимі сну. Ба більше, він зараховує лише так звані безперебійні процеси в режимі сну, тобто ті, яких нелегко розбудити.

Середнє навантаження можна переглянути, запустивши w, top або uptime. Ми пояснимо цифри далі.

--------------Інтерпретація значень середнього навантаження----------------------

Середнє навантаження відображається за допомогою трьох чисел – 0,45, 0,17 і 0,12 (на знімку екрана нижче).  Якщо припустити, що система з одним процесором, три числа середнього навантаження інтерпретуються таким чином:

0,45: за останню хвилину система була використана в середньому на 45%;
0,17: за останні 5 хвилин використання становило 17%;
0,12: за останні 15 хвилин використання становило 12%.
Якби ми побачили значення 1,00 на другій позиції, це означало би, що система з одним процесором використовувалася в середньому на 100% протягом останніх 5 хвилин. Це добре, якщо ми хочемо повністю використовувати систему. Значення понад 1,00 для системи з одним процесором означає, що система використовувалась надмірно: процесів, які потребували ЦП, було більше, ніж ЦП міг забезпечити.

Якби в нас був більше ніж один процесор, скажімо, система з чотирма процесорами, ми би розділили значення середнього навантаження на кількість процесорів. Наприклад, середнє навантаження 4,00 за 1 хвилину означає, що система загалом була використана на 100% (4,00 : 4) протягом останньої хвилини.

Короткострокові підвищення зазвичай не проблема. Пік, який ви бачите, радше за все є сплеском активності, а не новим рівнем. Наприклад, під час запуску багато процесів запускаються, а потім активність припиняється. Якщо в значеннях середнього навантаження за 5 і 15 хвилин спостерігається пік, це може бути приводом для занепокоєння.

-----------------Фонові процеси та процеси переднього плану-----------------------

Linux підтримує обробку завдань у фоновому та передньому планах. Завдання в цьому контексті – це просто команда, запущена з вікна термінала. Завдання переднього плану виконуються безпосередньо з оболонки, і, коли виконується одне завдання переднього плану, інші завдання мають чекати на доступ до оболонки (принаймні у цьому вікні термінала, якщо використовується графічний інтерфейс), доки воно не буде завершено. Добре, коли завдання виконуються швидко, проте це може мати негативний ефект, якщо виконання поточної роботи займе багато часу (навіть кілька годин).

У таких випадках ви можете запустити завдання у фоновому режимі та звільнити оболонку для інших завдань. Фонове завдання виконуватиметься з нижчим пріоритетом, що своєю чергою забезпечить безперебійне виконання інтерактивних завдань, і ви можете вводити інші команди у вікні термінала під час виконання фонового завдання. За замовчуванням усі завдання виконуються на передньому плані. Ви можете перевести завдання у фоновий режим, додавши знак «&» до команди, наприклад: updatedb &.

Ви можете натиснути CTRL+Z, щоби призупинити завдання переднього плану, або CTRL+C, щоби припинити його. Можете використовувати команди bg і fg, щоби запустити процес у фоновому та передньому плані відповідно.

-------------------Управління завданнями------------------------------------------

Утиліта jobs відображає всі завдання, що виконуються у фоновому режимі. На дисплеї відображається ідентифікатор завдання, стан і назва команди, як показано на знімку екрана. jobs -l надає ту саму інформацію, що й jobs, і додає PID фонових завдань. Фонові завдання підключаються до вікна термінала, тому, якщо ви вийдете з системи, утиліта jobs не відображатиме ті, які розпочато з цього вікна.

lopihara@DESKTOP-2PR8U4H:/mnt$ sleep 100 &
[1] 206
lopihara@DESKTOP-2PR8U4H:/mnt$ jobs
[1]+  Running                 sleep 100 &
lopihara@DESKTOP-2PR8U4H:/mnt$

---------------------Лабораторна робота 9.1. Uptime та середнє навантаження-------

Перевірте, як довго працює ваша система. Відобразіть її середнє навантаження.

Перегляньте запропонований розвʼязок лабораторної роботи.

Лабораторна робота 9.1. Розвʼязок

Найпростіший спосіб – використати утиліту uptime:       

student:/tmp> uptime

10:26:40 up  3:19,  5 users,  load average: 1.46, 1.40, 1.19

Другий спосіб: подивитися на перший рядок виведення зверху (далі обговоримо докладніше):

student:/tmp> top | head

top - 10:28:11 up  3:20,  5 users,  load average: 1.93, 1.52, 1.25
Tasks: 313 total,   1 running, 312 sleeping,   0 stopped,   0 zombie
%Cpu(s):  1.0 us,  0.3 sy,  0.0 ni, 98.2 id,  0.5 wa,  0.0 hi,  0.0 si,  0.0
KiB Mem : 16284472 total,  6556792 free,  1029760 used,  8697920 buff/cache
KiB Swap:  8290300 total,  8290300 free,        0 used. 10364220 avail Mem
 PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
 2615 coop      20   0  504536 186312  65488 S   6.7  1.1   6:28.30 skype-b+
18248 coop      20   0  655804  50816  30884 S   6.7  0.3   0:20.11 emacs
    1 root      20   0  204912   6508   3956 S   0.0  0.0   0:00.92 systemd

Третій спосіб – використання w:

student:/tmp> w

10:30:51 up  3:23,  5 users,  load average: 0.55, 1.11, 1.14
USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT
coop     :0       :0               07:08   ?xdm?  16:51   0.19s gdm-session-
coop     pts/0    :0               07:09    2:22m  0.12s  0.12s bash
coop     pts/1    :0               07:09    1:37m  0.42s  0.42s bash
coop     pts/2    :0               07:09    0.00s 51.09s  0.00s w
coop     pts/3    :0               07:09   27:08   0.25s  0.25s bash

----------------Лабораторна робота 9.2. Фонові завдання та завдання переднього плану----------------

Ми збираємося запустити графічну програму з вікна термінала, щоби більше не можна було друкувати у вікні. gedit – простий вибір, але ви можете замінити будь-яку іншу програму, яка це робить.

У файлі розвʼязку міститься покрокова процедура переведення завдань у фоновий режим, повернення їх на передній план тощо. Будь ласка, повторіть кроки, замінивши програму, яку ви використовуєте, якщо це не gedit.

Перегляньте запропонований ровзʼязок лабораторної роботи.

Ми збираємося запустити графічну програму з вікна термінала, щоби більше не можна було друкувати у вікні. gedit – простий вибір, але ви можете замінити будь-яку іншу програму, яка це робить.

1. Відкрийте gedit у новому файлі:

$ gedit somefile

Ви все ще можете вводити текст у вікні термінала, проте оболонка не звертатиме на це уваги.

2. Поки курсор над вікном термінала, натисніть CTRL+Z.

^Z  
[3]+  Stopped                 gedit somefile

Ви більше не можете вводити gedit у вікні.

3. За допомогою jobs -l можна переглянути, які процеси були запущені з цього вікна термінала:

$ jobs -l
[1]  17705 Running                 evince *pdf &
[2]- 18248 Running                 emacs /tmp/hello.tex &
[3]+ 19827 Stopped                 gedit somefile

4. Тепер перемістіть останнє завдання (gedit somefile) у фоновий режим:

$ bg
[3]+ gedit somefile &

Тепер ви повинні мати можливість вводити gedit у вікні.

5. Знову перемістіть процес на передній план:

$ fg
gedit somefile

Зверніть увагу, що ви знову вводите дані у вікні термінала, проте це не має ефекту.

6. Щоб очистити, призупиніть процес знову, а потім скористайтеся kill, щоби припинити його:

^Z
[3]+  Stopped                 gedit somefile
 $ jobs -l
 [1]  17705 Running                 evince *pdf 
 [2]- 18248 Running                 emacs /tmp/hello.tex 
[3]+ 19827 Stopped                 gedit somefile
 $ kill -9 19827
 $ jobs -l
 [1]  17705 Running                 evince *pdf &
 [2]- 18248 Running                 emacs /tmp/hello.tex &
 [3]+ 19827 Killed                  gedit somefile
 $ jobs -l
 [1]- 17705 Running                 evince *pdf &
 [2]- 18248 Running                 emacs /tmp/hello.tex &

 -------------------------Команда ps (стиль System V)--------------------------------------------

 Команда ps надає інформацію про поточні запущені процеси з PID. Якщо ви бажаєте періодично оновлювати цей статус, ви можете використовувати top або інші стандартні варіанти (наприклад, htop або atop) з командного рядка або викликати програму графічного системного монітору вашого дистрибутива.

Команда ps має багато параметрів для того, щоб уточнити, яке саме завдання досліджувати, яку інформацію про нього відображати та який саме вихідний формат слід використовувати.

Без параметрів команда ps відображатиме всі процеси, що виконуються в поточній оболонці. Ви можете використовувати параметр -u для відображення інформації про процеси вказаного користувача. Команда ps -ef детально відображає всі процеси в системі. Команда ps -eLf йде ще далі і відображає один рядок інформації для кожного потоку (пам’ятайте, що процес може містити кілька потоків).

----------------------Команда ps (стиль BSD)------------------------------------------------------

Команда ps має інший стиль специфікації параметрів, який походить від BSD – різновиду UNIX, де параметри вказуються без дефіса. Наприклад, команда ps aux відображає всі процеси всіх користувачів. Команда ps axo дозволяє вказати, які атрибути ви бажаєте переглянути.

На знімку екрана показано зразок виведення команди ps зі специфікаторами aux та axo.

------------------------------------Дерево процесів-----------------------------------------------

Команда pstree відображає процеси, що виконуються в системі, у формі деревоподібної діаграми, яка показує зв’язок між процесом і його батьківським процесом, а також будь-якими іншими процесами, які він створив. Повторювані записи процесу не відображаються, а потоки відображаються у фігурних дужках.

------------------------------------------top-----------------------------------------------------

Хоча статичне уявлення про те, що робить система, корисне, моніторинг продуктивності системи в реальному часі також важливий. Один з варіантів – запускати ps через регулярні проміжки часу, скажімо, кожні кілька секунд.  Проте краща альтернатива – використання top для отримання постійних оновлень у реальному часі (що дві секунди за замовчуванням), доки ви не вийдете, ввівши q.top. Буде чітко видно, які процеси споживають найбільше циклів ЦП та пам’яті (використовуючи відповідні команди з top).

-----------------------------Перший рядок інформації команди top----------------------------------

Перший рядок інформації команди top ілюструє короткий підсумок того, що відбувається в системі, зокрема:

скільки часу працює система,
скільки користувачів увійшли до системи,
що таке середнє навантаження.
Середнє навантаження визначає, наскільки навантажена система. Середнє навантаження 1,00 на ЦП вказує на повністю навантажену систему, проте не перевантажену. Якщо середнє навантаження перевищує це значення, це означає, що процеси змагаються за процесорний час. Якщо середнє навантаження дуже високе, це може означати, що в системі є проблема (наприклад, процес, що не працює або не відповідає).

-------------------------Другий рядок інформації команди top---------------------------------------

У другому рядку інформації команди top подається загальна кількість процесів, кількість запущених, у стані сну, зупинених і зомбі-процесів.  Порівняння кількості запущених процесів із середнім навантаженням допомагає визначити, чи досягла система своєї потужності чи, можливо, певний користувач виконує забагато процесів. Слід перевірити зупинені процеси, щоби зрозуміти, чи все працює правильно.

---------------------------Третій рядок інформації команди top-------------------------------------

У третьому рядку інформації команди top показано, як час процесора розподіляється між користувачами (us) і ядром (sy): подається відсоток часу процесора для кожного.

Потім буде показано відсоток завдань користувача, які виконуються з нижчим пріоритетом (niceness - ni). Режим простою (id) має бути низьким, якщо середнє навантаження високе, і навпаки. Указано відсоток завдань, які очікують (wa) на введення-виведення. До відсотку переривань входить відсоток апаратних (hi) і програмних (si) переривань. Крадений час (st) зазвичай використовується віртуальними машинами, у яких частина часу простою процесора використовується для інших цілей.

---------------------------Четвертий і п’ятий рядки інформації команди top-------------------------

У четвертому та п’ятому рядках інформації команди top указано використання пам’яті, яку поділено на дві категорії:

фізична пам’ять (RAM) (подається в четвертому рядку);
простір підкачки (подається в п’ятому рядку);
обидві категорії відображають загальну пам’ять, використану пам’ять і вільний простір.
Потрібно дуже ретельно стежити за використанням пам’яті, щоби забезпечити хорошу продуктивність системи. Коли фізична пам’ять вичерпується, система починає використовувати простір підкачки (тимчасовий простір для зберігання на жорсткому диску) як розширений пул пам’яті, і, оскільки доступ до диска відбувається набагато повільніше, ніж до пам’яті, це негативно вплине на продуктивність системи.

Якщо система починає часто використовувати підкачку, ви можете додати більше простору для підкачки. Однак також слід розглянути можливість додавання додаткової фізичної пам’яті.

--------------------------------Список процесів в інформації команди top---------------------------

Кожен рядок у списку процесів інформації команди top подає інформацію про процес. За замовчуванням процеси впорядковані за найбільшим використанням ЦП.  Відображається така інформація про кожен процес:

ідентифікаційний номер процесу (PID),
власник процесу (USER),
пріоритет (PR) і значення nice (NI),
віртуальна (VIRT), фізична (RES) і спільна пам’ять (SHR),
статус (S),
відсоток використання ЦП (%CPU) і пам’яті (%MEM),
час виконання (TIME+),
команда (COMMAND).

------------------------------Інтерактивні клавіші в top-------------------------------------------

Окрім виведення інформації, top можна використовувати інтерактивно для моніторингу та контролю процесів. Коли top працює у вікні термінала, ви можете вводити однолітерні команди, щоби змінити його поведінку. Наприклад, ви можете переглянути процеси з найвищим рейтингом на основі використання ЦП або пам’яті. За потреби ви можете змінити пріоритети запущених процесів або зупинити / убити процес.

У таблиці показано, що відбувається після натискання різних клавіш під час дії команди top:

Команда	Вивід
t	Показати або приховати підсумкову інформацію (рядки 2 і 3)
m	Показати або приховати інформацію про пам’ять (рядки 4 і 5)
A	Сортувати список процесів за найбільшими споживачами ресурсів
r	Відновити (змінити пріоритет) певних процесів
k	Убити певний процес
f	Увійти у конфігураційний екран top
o	Інтерактивно обрати новий порядок сортування в списку процесів

--------------------Планування майбутніх процесів за допомогою at----------------------------------

Припустімо, вам потрібно виконати завдання в якийсь конкретний день колись у майбутньому. Однак ви знаєте, що в цей день ви будете далеко від машини. Як ви виконаєте завдання?  Ви можете використовувати утиліту at для виконання будь-якої неінтерактивної команди в указаний час, як показано на знімку екрана нижче:

------------------------------------cron-----------------------------------------------------------

cron – це допоміжна програма для планування на основі часу. Вона може запускати рутинні фонові завдання в певний час і / або дні на постійній основі. cron керується конфігураційним файлом під назвою /etc/crontab (таблиця cron), що містить різні команди оболонки, які потрібно виконувати в призначений час. Існують як загальносистемні файли crontab, так і окремі файли користувача. Кожен рядок файлу crontab представляє завдання та складається з так званого виразу CRON, за яким слідує команда оболонки для виконання.

Введення crontab -e відкриє редактор crontab для редагування наявних або створення нових завдань. Кожен рядок файлу crontab міститиме 6 полів:

Поле	Опис	Значення
MIN	Хвилини	0 до 59
HOUR	Години	0 до 23
DOM	День місяця	1-31
MON	Місяць	1-12
DOW	День тижня	0-6 (0 = Неділя)
CMD	Команда	Будь-яка команда для виконання
Приклади:

Запис * * * * * /usr/local/bin/execute/this/script.sh запланує завдання для виконання script.sh кожну хвилину, кожну годину, кожен день місяця, а також кожен місяць і кожен день у тиждень.
Запис 30 08 10 06 * /home/sysadmin/full-backup запланує повне резервне копіювання на 8:30 ранку 10 червня, незалежно від дня тижня.

-----------------------------------sleep-----------------------------------------------------------

Іноді команду або завдання потрібно відкласти або призупинити. Припустімо, програма прочитала та обробила вміст файлу даних, а потім потребує збереження звіту в резервній системі. Якщо система резервного копіювання зараз зайнята або недоступна, програму можна перевести в режим сну (очікування), поки вона не завершить свою роботу. Такою затримкою може бути підключення пристрою резервного копіювання та його підготовка до запису.

sleep призупиняє виконання як мінімум на вказаний період часу, який можна вказати як кількість секунд (за замовчуванням), хвилин, годин або днів. Коли цей час мине (або буде отримано сигнал переривання), виконання буде відновлено.

Синтаксис:

sleep NUMBER[SUFFIX]...

де SUFFIX може бути:

s – протягом секунд (за замовчуванням),
m – протягом хвилин,
h – протягом годин,
d – протягом днів.
sleep і at – різні команди. sleep відкладає виконання на певний період, тоді як at починає виконання пізніше.

----------------------Лабораторна робота 9.3: Використання at для пакетної обробки в майбутньому------

Заплануйте виконання дуже простого завдання в майбутньому (буквально через одну хвилину). Це може бути так само просто, як запустити ls або date і зберегти результат.

Зауважте, що команда виконуватиметься в каталозі, з якого ви її запланували.

Зробіть це:

З короткого сценарію bash.
Інтерактивно.
Перегляньте запропонований розв’язок лабораторної роботи.

1. Створіть файл testat.sh, який містить:

#!/bin/bash
date > /tmp/datestamp

а потім зробіть його виконуваним і поставте в чергу за допомогою at:

$ chmod +x testat.sh
$ at now + 1 minute -f testat.sh

Ви можете побачити, чи стоїть завдання в черзі для виконання, за допомогою atq:

$ atq
17 Wed Apr 22 08:55:00 2015 a student

Переконайтеся, що завдання дійсно виконано:

$ cat /tmp/datestamp
Wed Apr 22 08:55:00 CDT 2015

Що станеться, якщо видалити /tmp/datestamp з команди? (Підказка: введіть mail, якщо цього не буде запропоновано!)

2. Інтерактивно це в основному та сама процедура. Просто поставте роботу в чергу за допомогою:

$ at now + 1 minute
at> date > /tmp/datestamp
CTRL-D
$ atq

---------------------------Лабораторна робота 9.4. Планування періодичного завдання за допомогою cron---------------

Налаштуйте cron, щоби виконувати якесь просте завдання щодня о 10:00.

Перегляньте запропонований розв’язок лабораторної роботи.

Налаштуйте cron, щоби виконувати якесь просте завдання щодня о 10:00.  Створіть файл із назвою mycrontab із таким вмістом:

0 10 * * * /tmp/myjob.sh

а потім створіть /tmp/myjob.sh, що вміщує 

#!/bin/bash
echo Hello I am running $0 at $(date)

і зробіть його виконуваним:

$ chmod +x /tmp/myjob.sh

Помістіть його в систему crontab за допомогою:

$ crontab mycrontab

і переконайтеся, що його завантажено:

$ crontab -l

0 10 * * * /tmp/myjob.sh
$ sudo ls -l /var/spool/cron/student
-rw------- 1 student student 25 Apr 22 09:59 /var/spool/cron/student
$ sudo cat /var/spool/cron/student
0 10 * * * /tmp/myjob.sh

Примітка: якщо ви не хочете, щоб це запускалося щодня, виводьте такі повідомлення:

Привіт, я працюю /tmp/myjob.sh at Wed Apr 22 10:03:48 CDT 2015

Надсилаючи його собі на електронку, ви зможете видалити його за допомогою:

$ crontab -r

Якщо машина не працює о 10:00 у певний день, anacron запустить завдання у відповідний час.

-------------------------------ороткий зміст розділу-------------------------------------------

Ви завершили розділ 9. Підсумуймо основні розглянуті поняття:

Процеси використовують для виконання різноманітних завдань у системі.
Процеси можуть бути однопотоковими або багатопотоковими.
Процеси можуть бути різних типів, наприклад інтерактивні та неінтерактивні.
Кожен процес має унікальний ідентифікатор (PID), який дозволяє операційній системі відстежувати його.
Значення nice або niceness можна використовувати для встановлення пріоритету.
ps надає інформацію про поточні запущені процеси.
Ви можете використовувати top, щоб отримувати постійні оновлення в реальному часі про загальну продуктивність системи, а також інформацію про процеси, що виконуються в системі.
Середнє навантаження вказує на рівень використання системи в певний час.
Linux підтримує фонову та активну обробку завдань.
at виконує будь-яку неінтерактивну команду у вказаний час.
cron використовують для планування завдань, які потрібно виконувати через регулярні проміжки часу.